% !TeX spellcheck = cs_CZ
% !TeX root = projekt.tex

\newcommand{\ctime}{\inlineCode{@ctime}\xspace}
\newcommand{\nonctime}{ne-\inlineCode{@ctime}\xspace}

\chapter{Úvod}
Tento dokument popisuje a zdůvodňuje část z mnoha rozhodnutí, která byla vykonána při procesu návrhu programovacího jazyka Beast a vzorového překladače pro něj. Rámcově prozkoumává syntaktické i sémantické prvky moderních programovacích jazyků a popisuje i nové koncepty a prvky. Prvkem jazyka, na kterou se tato práce zaměřuje, je nový koncept "líhnutí kódu", který poskytuje rozsáhlé možnosti metaprogramování.

Programovací jazyk se hodně inspiruje jazyky C++ a D\footnote{\url{http://dlang.org/}}. Tyto jazyky budou používány pro srovnávání syntaxe a efektivity psaní kódu.

Příklady kódů z jazyka Beast uvedené v tomto dokumentu čerpají z kompletní specifikace jazyka, případně pracují s fiktivní standardní knihovnou; kompilátor vytvořený v~rámci bakalářské práce ale implementuje pouze její podmnožinu -- většinu uvedených kódů tedy kompilátor není schopný zpracovat.

\section{Motivace}
Kompilované jazyky jsou základním stavebním kamenem softwarového průmyslu. 

\begin{comment}
Mou hlavní motivací je nespokojenost se stávajícími programovacími jazyky. Programování mám jako koníčka už od nějakých dvanácti let, a tak jsem ještě před nastoupením na FIT získal nějaké zkušenosti z psaní aplikací v Object Pascalu (Delphi), C++ (Qt, SDL + OpenGL) a PHP (webové aplikace). FIT pak můj repertoár (i když jen rámcově) rozšířil na valnou většinu dnes používaných jazyků. Bohužel jsem ale nenarazil na žádný, který by splňoval mé požadavky. Rozhodl jsem se tedy využít nutnost napsání bakalářské práce k~uskutečnění mého dlouholetého snu.

\paragraph{Jazyk D}
Mému srdci nejbližší jazyk, na který jsem ve svém pátrání narazil, byl jazyk D. Jedná se o kompilovaný jazyk vycházející z C++ (binárky jsou do jisté míry kompatibilní) s~velice podobnou syntaxí. Největší rozdíly jsou modulový systém\footnote{\url{http://dlang.org/spec/module.html}} (zdrojový kód je rozdělen do modulů, které se vzájemně, i rekurzivně, importují; odpadá nutnost psát hlavičkové soubory), značně rozšířená funkčnost metaprogramování s šablonami a~rozšířená schopnost vykonávat funkce za doby kompilace.

D mi byl velikou inspirací při navrhování mého jazyka. Bohužel i v D jsem narazil na strop možnosti (ačkoli byl značně výš než třeba v C++), kdy některé věci nešly napsat tak jednoduše, jak bych chtěl. Tento jazyk však dokazuje, že tato bariéra může být mnohem dál. Já ji chci ve svém jazyku ještě více posunout. 
\end{comment}


\section{Cíle}

\chapter{Vlastnosti a syntaxe jazyka}
Nejdříve musíme určit základní rysy jazyka, které potom budeme dále rozvíjet.

\paragraph{Použití jazyka}
Naším cílem je navrhnout tzv. \textit{general purpose language}, tedy jazyk nezaměřený na konkrétní případy užití. Cílíme vytvořit "nástupce" jazyka C++, který by se dal použít ve všech případech, kde se dá využít C++ -- tedy i třeba na mikroprocesorových systémech. Složitější struktury se tím pádem budeme snažit řešit spíše vhodnou abstrakcí než zaváděním prvků, které kladou zvýšené nároky na výkon a paměť.

\paragraph{Kompilovaný vs. interpretovaný jazyk}
Ačkoli interpretované jazyky mají jisté výhody, platí se za ně pomalejším kódem a nutností zavádět interpret. V rámci této práce budeme navrhovat kompilovaný jazyk. Pro zjednodušení práce při psaní překladače nebudeme ale překládat přímo do strojového kódu, ale do jazyka C.

\paragraph{Syntaxe jazyka}
Abychom maximálně usnadnili přechod případných programátorů k našemu jazyku a zkrátili učební křivku, je vhodné se co nejvíce inspirovat již existujícími jazyky. Vzhledem k tomu, že se jedná o~kompilovaný jazyk, je nejrozumnější vycházet se syntaxe rodiny jazyků C, které jsou hojně rozšířené a zažité.

\paragraph{Programovací paradigmata}
Jelikož vycházíme z jazyků C++ a D, přejímáme i jejich paradigmata a základní koncepty. Náš jazyk bude tedy umožňovat strukturované, funkcionální i objektově orientované programování.

\section{Existující prvky programovacích jazyků}

\subsection{Systém dedičnosti tříd} Jazyky C++ a D mají různě řešené třídní systémy. Zatímco v C++ existuje jen jeden typ objektu, který pracuje s dědičností (\textit{class} a \textit{struct} jsou z pohledu dědění identické), a to s dědičností vícenásobnou a případně i~virtuální, D~má systém spíše podobný Javě -- třídy (\textit{class}) mohou mít maximálně jednoho rodiče, navíc ale existují rozhraní (\textit{interface}), které však nemohou obsahovat proměnné.

Ačkoli vícenásobné dědění není třeba často, občas potřeba je a jen těžko se nahrazuje. Rozhraní nemohou obsahovat proměnné, což omezuje jejich možnosti. D nabízí ještě jedno řešení -- tzv. \textit{template mixins}\footnote{\url{https://dlang.org/spec/template-mixin.html}} -- které funguje velice podobně jako kopírování bloků kódu přímo do těla třídy. Toto řešení rozbíjí model dědičnosti (na \textit{mixiny} se nelze odkazovat, nefungují jako rozhraní); navíc, protože jsou vložené funkce prakticky součástí třídy, nefunguje v určitých případech kontrola přepisování (\textit{overridingu}).

Ačkoli je implementace systému vícenásobné dědičnosti tak, jak je například v C++, složitější, její implementace je uskutečnitelná, kód nezpomaluje a fakticky rozšiřuje možnosti jazyka. C++ model dědičnosti umí vše, co umí Javovský model, a ještě víc.

Jazyk Beast tedy bude umožňovat třídní dědičnost, a to způsobem podobným C++. Nicméně implementace systému třídní dědičnosti není primárním cílem projektu, a tak je možné, že v rámci bakalářské práce nebude plně implementován.

Dá se přemýšlet i o zavedení různých direktiv, které umožňují dále nastavovat tento systém -- tedy například přidat možnost nastavení zamezení generování tabulky virtuálních metod, atp.

\subsection{Automatická správa paměti -- garbage collector}
Spousta moderních jazyků (mezi nimi i D) obsahuje garbage collector (dále GC) v základu. Jeho zavedení nenabízí pouze výhody -- programy mohou být pomalejší, GC zvyšuje nároky na CPU a paměť (těžko se zavádí v mikroprocesorech); navíc efektivní implementace GC je velice složitá.

Rozumným kompromisem se jeví být volitelné používání automatické správy paměti. Beast by měl umožňovat efektivní napsání GC přímo v jazyce; GC by tedy mohla být jedna ze základních knihoven jazyka. Vzhledem k už tak velkému rozsahu plánované práce je však GC jen plánem do budoucna.

\subsection{Implicitní konstantnost proměnných a propagace konstantnosti}
Koncept konstantnosti proměnných byl zaveden jednak jako prvek kontroly při psaní kódu, jednak zvětšil potenciál kompilátorů při optimalizování kódu. Označení proměnné za konstantní ale u jazyku C++ (i D, Java, ...) vyžaduje ale napsání dalšího slova (modifikátoru \textit{const} u C, C++ a D, \textit{final} u Javy), a tak tuto praktiku (označovat všechno, co se dá, jako konstantní) spousta programátorů neaplikuje, zčásti kvůli lenosti, zčásti kvůli zapomnětlivosti.

Některé jazyky (například Rust\footnote{\url{https://doc.rust-lang.org/nightly/book/mutability.html}}) přišly s opačným přístupem -- všechny proměnné jsou implicitně konstantní a programátor musí použít nějakou syntaktickou konstrukci k tomu, aby to změnil. Beast tento přístup také zavede. V rámci koherence syntaxe jazyka (která je rozvedena v dalších kapitolách tohoto textu), připadají v úvahu dvě možnosti:
\begin{enumerate}
	\item Vytvoření dekorátoru v kontextu \inlineCode{typeWrapper}\footnote{\BeastRef{Decoration contexts}}, nejlogičtěji \inlineCode{@mutable} nebo \inlineCode{@mut}
	\item Vyčlenění operátoru; nejlepším kandidátem je suffixový operátor \inlineCode{Type!}, protože nemá žádnou standardní sémantiku, je nepoužitý a znak vykřičníku je intuitivně asociován s výstrahou, což je zase asociovatelné s mutabilitou.
\end{enumerate}

Při designu Beastu byla zvolena druhá možnost, především kvůli "upovídanosti" kódu a~ještě kvůli jednomu důvodu, který je popsán níže.

\paragraph{Propagace konstantnosti} \label{constPropagation} Jazyk D je navržen tak, že je-li ukazatel konstantní (nelze měnit adresu, na kterou ukazuje), je přístup k paměti, na kterou ukazuje, také konstantní. Není tedy možné mít konstantní ukazatel na nekonstantní paměť. Tento mechanismus se nejvíce projevuje při konstantním referencování dat:
\begin{dcode}
// D
class C {
	int *x;
}

void main() {
	C c = new C;
	c.x = new int( 5 );
	
	const C c2 = c;
	*c2.x = 6; // Error: cannot modify const expression *c2.x
}
\end{dcode}

Toto je zbytečné limitování; tranzitivní konstantnost může být v některých případech užitečná, nicméně existují případy užití, ve kterých je překážkou. V Beastu tedy nebude vynucená propagace konstantnosti; můžeme mít konstantní ukazatel na nekonstantní data.

Chceme-li mít nekonstantní ukazatel na nekonstantní data, musíme tedy specifikovat mutabilitu dvakrát. Syntaktický zápis pro takovou referenci by vypadal takto (syntaxe pro referenci je \inlineCode{Typ?}, viz \ref{pointers}; příklady reflektují alternativy syntaktického zápisu referencí, které jsou uvedené výše v tomto oddílu):
\begin{enumerate}
	\item \inlineCode{@mut ( @mut Typ )?}
	\item \inlineCode{Typ!?!}
\end{enumerate}

Další možností by bylo zcela využít gramatiku C++, nicméně ta je všeobecně považována za velice matoucí -- dochází tam ke kombinování suffixových a prefixových modifikátorů podle neintuitivních pravidel. Čistě suffixový zápis je jasný a jednoduchý a~značně snižuje potřebu využívat závorek.

\paragraph{Srovnání syntaxe C++, D a Beast}
\begin{cppcode}
	// C++
	int a, b; // Mutable integer
	const int c, d; // Const integer
	int *e, *f; // Mutable pointer to mutable integer
	const int *g, *h; // Mutable pointer to const integer
	int * const i, * const j; // Const pointer to mutable integer
	const int * const k, * const l; // Const pointer to const integer
\end{cppcode}
\begin{dcode}
	// D
	int a, b; // Mutable integer
	const int c, d; // Const integer
	int* e, f; // Mutable pointer to mutable integer
	const( int )* g, h; // Mutable pointer to const integer
	// const pointer to mutable integer not possible
	const int* k, l; // Const pointer to const integer
\end{dcode}
\begin{code}
	// Beast
	Int32! a, b; // Mutable integer
	Int32 c, d; // Const integer
	Int32!?! e, f; // Mutable reference to mutable integer
	Int32?! g, h; // Mutable reference to const integer
	Int32!? i, j; // Const reference to mutable integer
	Int32? k, l; // Const reference to const integer
\end{code}

\subsection{Typová kontrola a konverze typů}
Beast má podobný mechanismus typových kontrol jako jazyky C++ a D:
\begin{itemize}
	\item Typy mohou být implicitně konvertibilní do jiných typů. Proces konverze je definován v jednom z typů (přetížením funkcí \inlineCode{#implicitCastTo} nebo \inlineCode{#implicitCastFrom})\footnote{\BeastRef{Type casting}}. Implicitní konverze se provádí sama v případě potřeby\footnote{Implicitní konverze ovlivňuje rezoluci volání přetížených funkcí, \beastRef{Overload resolution}}.
	\item Typy mohou být explicitně konvertibilní do jiných typů (funkce \inlineCode{#explicitCastTo} a~\inlineCode{#explicitCastFrom}). K explicitnímu přetypování se používá výhradně funkce \inlineCode{a.to( Type )} (lze použít i k implicitnímu přetypování).
\end{itemize}

Důvodem k jiné syntaxi oproti C++ je opět snaha o zjednodušení pravidel a zvýšení přehlednosti kódu.

\begin{cppcode}
// C++
const int x = *( ( const int* )( voidPtr ) );
\end{cppcode}

\begin{code}
// Beast
Int x = voidRef.to( Int? );
\end{code}

\subsection{Reference, ukazatelé a jejich syntaxe} \label{pointers}
Typ ukazatel umožňující ukazatelovou aritmetiku je v dnešní době považován za potenciálně nebezpečný prvek, který by se měl užívat jen v nutných případech. Toto se řeší zavedením referencí, které v různých jazycích fungují mírně rozdílně, všeobecně se ale dá říci, že se jedná o ukazatele, které nepodporují ukazatelovou aritmetiku.

V C++ reference neumožňují měnit adresu odkazované paměti. V praxi ale programátor poměrně často potřebuje měnit hodnotu odkazu a~musí se proto uchylovat k ukazatelům, které podporují ukazatelovou aritmetiku a pro přístup k odkazované hodnotě je třeba buď použít dereferenci (která je implementována prefixovým operátorem \inlineCppCode{*ptr} a má tendenci znepřehledňovat kód) nebo speciální syntaktickou konstrukci (místo \inlineCppCode{x.y} \inlineCppCode{x->y}) pro přístup k prvkům odkazované hodnoty.

D k problematice přistupuje takto:
\begin{itemize}
	\item Třídy jsou vždy předávané odkazem; adresa odkazované instance třídy se dá měnit, ukazatelová aritmetika není podporována (jako v Javě), přetěžování operátoru \inlineCode{a = b} není povoleno pro třídy jako levé operandy. Kromě tříd existují i struktury, které jsou předávané hodnotou; ty však nepodporují dědičnost.
	\item Existuje typ ukazatel, který pracuje s ukazatelovou aritmetikou. Pro přístup k odkazovanému prvku je třeba použít dereferenci (\inlineCode{*x}); k prvkům odkazované hodnoty lze použít klasické \inlineCode{x.y} (u C++ je třeba \inlineCode{x->y}). U dvojitého ukazatele je již potřeba použít dereferenci.
	\item Existuje i reference podobná té v C++, nicméně ta se dá použít pouze v několika málo případech (například v parametrech a návratových typech funkcí)
\end{itemize}

Vynucené předávání referencí má ale několik nevýhod:
\begin{itemize}
	\item Programátor musí zajišťovat konstrukci (případně i destrukci) objektů
	\item Způsobuje více alokací a dealokací
	\item Indirekce býva i tam, kde by být nemusela
\end{itemize}

\paragraph{Řešení Beastu} 
Beast má umožňovat nízkoúrovňové programování, typ ukazatel s ukazatelovou aritmetikou je tedy nutné zavést. Na druhou stranu je ale vhodné nabídnout alternativu pro "běžné" případy užití, které se většinou týkají vytváření instancí tříd na haldě a manipulace s nimi. Proto náš jazyk nabízí dva ukazatelové typy, kterým říkáme ukazatel a reference.

Způsob deklarace ukazatelů je v C++ i D problematický z hlediska parsování. Výraz \inlineCode{a * b} může totiž znamenat buď výraz násobení \inlineCode{a} krát \inlineCode{b}, stejně tak ale může znamenat deklaraci proměnné \inlineCode{b} typu ukazatel na \inlineCode{a}~(obdobně i u reference). Nejjednodušším řešením je použití jiného znaku pro označování ukazatelů.

V Beastu je tímto znakem otazník (\inlineCode{?}). V~C++ a~D~je používán pouze v ternárním operátoru (\inlineCode{cond ? expr1 : expr2}), kteréhož funkčnost Beast obstarává jiným způsobem\footnote{Viz \ref{ternary}}; tím pádem je znak otazníku "postradatelný".

Ukazatel funguje skoro stejně jako v C++; podporuje ukazatelovou aritmetiku. Na dereferenci se nepoužívá prefixový operátor \inlineCode{*ptr} kvůli gramatickým konfliktům a protože může způsobovat nepřehlednost kódu a nejasnosti v prioritě operátorů (například u výrazu \inlineCppCode{*p++}). Místo toho se používá \inlineCode{ptr.data}. Přístup k prvkům odkazované hodnoty je možný pouze pomocí dereference. K získání ukazatele se také, kvůli stejným důvodům jako u dereference, nepoužívá prefixový operátor \inlineCppCode{&variable}, nýbrž \inlineCode{variable.addr}. Typ ukazatel není deklarován pomocí zvláštní syntaktické konstrukce (suffixový operátor \inlineCode{Typ?} přenechává hojněji používaným referencím), jedná se o kompilátorem definovanou třídu \inlineCode{Pointer(Type referencedType)}.

Reference je podobná referencím v C++, navíc ale umožňuje změnu odkazované adresy (může mít i hodnotu \inlineCode{null}). Neumožňuje zanořování -- nelze definovat referenci na referenci (ukazatel na referenci ale možný je). Chová se stejně jako odkazovaná hodnota, až na několik výjimek:
\begin{itemize}
	\item Je přetížen operátor \inlineCode{ref := var} a \inlineCode{ref := null}, který je určen pro změnu odkazované adresy reference.
	\item Je přetížen operátor \inlineCode{ref is null}, který navrací, zda má reference hodnotu \inlineCode{null}.
	\item \inlineCode{ref.addr} vrací ukazatel na referenci. \inlineCode{ref.refAddr} vrací ukazatel na odkazovaný objekt.
\end{itemize}

Všechny typy jsou implicitně konvertibilní na referenci (daného typu i jeho předků) a~reference je explicitně konvertibilní na odkazovaný typ. Reference jsou implicitně konvertibilní na reference předků odkazované třídy a explicitně konvertibilní na referenci jakéhokoli typu; při těchto explicitních konverzích probíhá dynamická typová kontrola a jejich výsledek může být \inlineCode{null}.

Reference v Beastu pokrývají naprostou většinu případů užití ukazatelů při programování na vyšších úrovních abstrakce, a to se syntaxí takovou, že programátor nemusí rozlišovat referenci od normální proměnné. K programování na nižší úrovni se dá použít konvenční typ ukazatel \inlineCode{Pointer( T )}.

\subsection{Dekorátory}

\subsection{Vykonávání fukncí za doby kompilace}

\subsection{Metaprogramování}

\paragraph{Deklarace s \inlineDCode{if} v D}

\subsection{Mixiny}

\subsection{Unified function call syntax (UFCS)}

\subsection{Systém výjimek}

\subsection{Lambda výrazy}

\subsection{Rysy (traits)}

\subsection{Standardní knihovna}

\section{Nové a netypické koncepty}

\subsection{Konstrukce \inlineCode{:ident}}

\subsection{Znak \inlineCode{\#} v identifikátorech}

\subsection{Ternární operátor} \label{ternary}

\subsection{Konstrukce \inlineCode{switch}}

\subsection{Vnořovatelné komentáře}

\subsection{Řetězcové literály}

\subsection{Typy IntXX, BinaryXX a Index}

\chapter{Koncept líhnutí kódu (\textit{code~hatching})}
Toto je nový koncept navržený pro jazyk Beast. Zasahuje do několika již známých konceptů -- například šablonové metaprogramování, reflexe jazyka, vykonávání funkcí za doby kompilace; všechny tyto koncepty spojuje do jednoho koherentního celku.

Koncept zavádí jednu jednoduchou myšlenku, ze které pak vyplývá celá řada důsledků. Tou myšlenkou je \textbf{zavedení klasifikátoru pro proměnné, jejichž hodnota se dá zjistit} bez nutnosti spouštět program. Tímto klasifikátorem je v~jazyce Beast dekorátor \ctime.

Vykonávání kódu tak probíhá ve dvou fázích -- hodnoty proměnných označených dekorátorem \ctime jsou odvozeny již za doby překladu, zbytek je vypočítáván za běhu samotného programu. \textbf{Toto se dá připodobnit k líhnutí vajec}, kdy se zárodek vyvíjí za skořápkou, ukryt před světem, a světlo světa spatří až jako vyvinutý jedinec.

\section{Dedukce axiomů}
Máme vyřčenou základní myšlenku -- hodnoty proměnných označených dekorátorem \ctime musíme být schopni odvodit již během kompilace; nyní tuto myšlenku budeme rozvádět. Začneme jednoduchým příkladem:
\begin{code}
@ctime Int x = 8;
\end{code}

Zde je vše jasné. Proměnná je konstantní, takže se nemůže měnit; po celou dobu její existence je její hodnota osm.

\subsection{Datové závislosti} \label{ctimeDataDependency}
Další jednoduchý příklad:
\begin{code}
@ctime Int x = console.read( Int );
\end{code}

Zde je zřejmé, že proměnná \inlineCode{x} nesplňuje naše požadavky. Příkaz \inlineCode{console.readNumber()} čte data z konzole a návratová hodnota této funkce se nedá zjistit bez spuštění programu (mohli bychom požádat o vstup již během kompilace, pro demonstraci konceptu ale toto nyní neuvažujme). Z~příkladu vyplývá, že \ctime proměnná nemůže být datově závislá na volání alespoň některých funkcí.

\begin{code}
Int add( Int x, Int y ) {
	return x + y;
}

Void main() {
	@ctime Int a = add( 5, 3 );
}
\end{code}
V tomto příkladě lze hodnotu proměnné \inlineCode{a} určit. \ctime proměnné tedy můžou být datově závislé na volání funkcí, ale jen některých.

\begin{code}
Int foo( Int x ) {
	if( x < 3 )
		return console.read( Int );

	return x + 1;
}

Void main() {
	@ctime Int a = foo( 5 );
	@ctime Int b = foo( 3 );
}
\end{code}

Tento příklad ukazuje, že to, zda funkci lze použít pro výpočet hodnot \ctime proměnných, může záležet na předaných parametrech.

\textbf{Funkce tedy k výpočtu hodnot \ctime proměnných všeobecně mohou být použity.} To, jestli funkce opravdu lze použít, se zjistí až během vykonávání. Nelze použít žádné funkce, u kterých kompilátor nezná chování nebo závisí na externích datech (soubory, čas, vstup uživatele, ...).

Z tohoto úhlu pohledu nemá funkce smysl označovat dekorátorem \inlineCode{@ctime}; níže v této kapitole je popsáno, že se tento dekorátor na funkce používá, ale s~trochu jiným účelem.

Všeobecně se dá říci, že \ctime proměnné nemohou být závislé na \nonctime datech. Hodnoty \nonctime proměnných mohou sice být odvoditelné bez nutnosti spuštění programu, ale nemusí. Teoreticky by bylo možné klasifikátor vynechat a odvozovat to pouze z~kódu, v praxi by toto však značně zpomalilo kompilaci. Předpokládejme tedy, že \textbf{hodnoty všech proměnných, které nejsou \ctime, se před spuštěním programu nedají odvodit.}

\subsection{Konstantnost}
Nyní zauvažujme nad tím, co se stane, když budeme chtít měnit hodnoty \ctime proměnných:

\begin{code}
@ctime Int! x = 8;
/* code here */
x += 2;
/* code here */
\end{code}

Zde je také všechno v pořádku. Ctime proměnné tedy nemusí být vždy konstantní.

\begin{code}
@static @ctime Int! x = 5;

Void foo() {
	@ctime Int! y = 5;
	console.write( x, y, '\n' );
	y += 3;
	x += 3;
	console.write( x, y, '\n' );
}

Void foo2() {
	x += 2;
}

Void main() {
	while( true ) {
		if( console.read( Int ) < 2 )
			foo();
		else
			foo2();
	}
}
\end{code}

Tady už narážíme na problém. Za doby kompilace nemůžeme zjistit hodnotu proměnné \inlineCode{x}, protože se mění na základě uživatelského vstupu (podle výsledku \inlineCode{console.read(Int)} se totiž volá buď funkce \inlineCode{foo} nebo \inlineCode{foo2}, obě manipulují s proměnnou \inlineCode{x}). Nekonstantní statické proměnné se nedají ohlídat, \textbf{\ctime statické proměnné tedy musí být vždy konstantní}.

\subsection{Podmínky a cykly}
Větvení \textit{if-then-else} a cykly sdílejí stejný princip -- různé chování na základě hodnoty nějakého výrazu. Pravidla odvozená v tomto oddílu platí pro všechna větvení stejně.

\begin{code}
Void main() {
	@ctime Int! x = 5;
	
	while( x < 6 ) $\label{ctime:branch:1}$
		x += 3;

	Int y = console.read( Int );
	if( y < 2 ) $\label{ctime:branch:2}$
		x += 8;
}
\end{code}

Z řádku \ref{ctime:branch:1} je patrné, že větvení v rámci \ctime proměnných je možné. Řádek \ref{ctime:branch:2} zase ukazuje, že to není možné vždy. Pokud je větvení datově závislé na výrazu, jehož hodnota se dá odvodit za doby kompilace (dále jen \ctime výrazu), mohou být v jeho těle přítomny \ctime proměnné. Pro usnadnění práce kompilátoru a zpřehlednění kódu Beast vyžaduje, aby \ctime větvení byly označeny dekorátorem (jinak se k nim přistupuje jako k \nonctime, viz dále).

Problematika je ale trochu složitější:

\begin{code}
Void main() {
	@ctime Int! y = 6;

	while( console.read( Int ) < 5 ) {
		@ctime Int! z = 3;
				
		console.write( y );	$\label{ctime:branch:3}$
		console.write( z );
		
		z += 4;
		console.write( z + y );
		
		y += 2;
	}
}
\end{code}

Zde máme proměnnou \inlineCode{z}, která je definovaná v těle \nonctime cyklu. Nicméně takovéto použití proměnné naše požadavky nenarušuje, stejně tak čtení z proměnné \inlineCode{y} na řádku \ref{ctime:branch:3}. V \nonctime větveních tedy mohou být použity \ctime proměnné a dokonce i definovány nekonstantní \ctime proměnné. Pravidlo, které se z tohoto příkladu dá vyvodit, je že \textbf{v tělech \nonctime větvení nelze měnit hodnoty \ctime proměnných deklarovaných mimo něj.}

\subsection{Tranzitivita \ctime}
Je zřejmé, že je-li proměnná \ctime programátorem definovaného třídního typu, musí být pro danou proměnnou všechny třídní proměnné toho typu také \ctime.

\begin{code}
class C {
	@public Int x, y;
}

Void main() {
	@ctime C c;
	c.x = 5; // c.x is @ctime
}
\end{code}

\subsection{Reference a dynamické alokace} \label{ctime:ref}
Pro praktickou demonstraci tohoto problému je již třeba složitější příklad:
\begin{code}
class BinaryTreeNode {
	
@public:
	String key;
	Int! value;
	BinaryTreeNode!?! left, right;
	
}
	
class BinaryTree {

@public:
	BinaryTreeNode!?! root;
	
@public:
	Void insert!( String key, Int value ) { ... }
	
	/// BinaryTree[ "key" ] lookup
	Int #operator( Operator.brackets, String key ) { ... }

}

BinaryTree sampleTree() {
	BinaryTree result;
	result.insert( "beast", 3 ); $\label{ctime:ref:2}$
	result.insert( "best", 5 ); $\label{ctime:ref:3}$
	
	result.top.data = 10;
}

@static @ctime BinaryTree tree = sampleTree(); $\label{ctime:ref:1}$

Void main() {
	console.write( tree["beast"] ); // the tree is @ctime, so the compiler is capable of looking up value in the binary tree at compile time, making this code extremely fast when running
	
	tree.root.value = 7; // tree is const, but tree.root is not $\label{ctime:ref:4}$
}
\end{code}

Zde jsme si na řádku \ref{ctime:ref:1} definovali \ctime proměnnou \inlineCode{tree}.  Třída \inlineCode{BinaryTree} potřebuje pro svou správnou funkčnost i bloky dynamicky alokované paměti (listy stromu; v~kódu to explicitně uvedeno není, nicméně z jeho sémantiky to vyplývá). Ty pro správnou funkčnost stromu také musí splňovat podmínky \ctime. Ačkoli by teoreticky bylo možné mít \ctime ukazatel na \nonctime paměť (za doby kompilace by se vědělo, kam ukazatel odkazuje, ale ne, co na té paměti je), výhodnější je udělat \ctime tranzitivní i přes ukazatele a reference. Pokud bychom to takto nenastavili, kód příkladu tohoto oddílu by pro fuknčnost vyžadoval zvláštní úpravy, nebo by nemohl fungovat vůbec.

Protože \inlineCode{tree} je statická \ctime proměnná, musí být konstantní. Dynamicky alokované bloky (listy stromu) vytvořené při její inicializaci tedy také musí být konstantní. Toto ale neplatí zcela -- během inicializace proměnné \inlineCode{tree} (během vykonávání funkce \inlineCode{sampleTree} za doby kompilace) s bloky normálně manipulujeme (řádky \ref{ctime:ref:2} a \ref{ctime:ref:3}). Tyto bloky se tedy stávají konstantními až \textit{po} dokončení inicializace. Zde vyvstává problém -- v naší třídě \inlineCode{BinaryTree} je ukazatel na dynamicky alokovaný blok typu \inlineCode{BinaryTreeItem!?!} -- odkazovaná paměť je z odkazu mutabilní. Řádek \ref{ctime:ref:4} je tedy technicky korektní, i když by podle výše uvedených myšlenek neměl být.

Jak tedy zajistit, aby se po inicializaci proměnné \inlineCode{tree} nedalo k jejím listům přistupovat přes mutabilní reference? Tento problém by se dal vyřešit zavedením vynucené tranzitivity konstantnosti referencí a ukazatelů -- tedy že při konstantní referenci/ukazateli by se odkazovaná paměť automaticky brala jako také konstantní. V oddílu \ref{constPropagation} jsme ale rozhodli, že jazyk Beast nebude vynucovat propagaci konstantnosti přes reference -- programátor si ji musí zajistit sám tam, kde je to potřeba. U binárního stromu je logické, že je-li konstantní strom, měly by jeho listy být také konstantní; v případě programátorem definovaných typů ale nelze zaručit, že je mutabilita korektně ošetřena.

Při kompilaci se konstantní statické proměnné v některých kompilátorech umísťují do tzv. \textit{.text section} ve výsledném binárním souboru. Stránky paměti načtené z těchto sekcí jsou chráněny operačním systémem proti zápisu a pokus o zapsání do nich vyvolává běhovou chybu (\textit{segfault/access violation}). Beast řeší problém obdobným způsobem -- při pokusu o~zápis do paměti (během kompilace), která byla alokována během inicializace statické \ctime (nebo i jen konstantní) proměnné, mimo dobu inicializace zmíněné proměnné vyvolá kompilátor chybu. Dalším prvkem ochrany je zákaz existence mutabilních referencí a ukazatelů na dané bloky mimo rámec inicializované proměnné.

\subsection{Konverze na \nonctime}
Je vhodné objasnit, že dekorátor \inlineCode{@ctime} není modifikátor typu (\inlineCode{typeModifier}\footnote{\BeastRef{Decoration contexts}}), ale modifikátor proměnné/parametru (\inlineCode{parameterModifier}/\inlineCode{variableModifier}). To znamená, že typy proměnných \inlineCode{ref} a \inlineCode{cref} v příkladu \ref{ctime:nonctime:3} jsou shodné (\inlineCode{ref.#type == cref.#type == Int!?}). Zákaz přiřazování výrazů závislých na \nonctime datech do \ctime proměnných je řešen jinak než typovou kontrolou.

\begin{code}[\label{ctime:nonctime:3}]
Void main() {
	@ctime Int! x = 3;
	
	@ctime Int!? cref := x;
	cref = 9; $\label{ctime:nonctime:1}$
	
	Int!? ref := cref; $\label{ctime:nonctime:2}$
	
	if( console.read( Int ) < 5 )
		ref := 8;
		
	@ctime Int y = x;
}
\end{code}

Výše uvedený příklad neporušuje žádné z pravidel, které jsme si již odvodili, nicméně hodnota proměnné \inlineCode{y} již není odvoditelná během kompilace, protože se hodnota proměnné \inlineCode{x}~může změnit na základě uživatelského vstupu. Přiřazení do \inlineCode{cref} na řádku \ref{ctime:nonctime:1} je v pořádku; kontrola nad daty se ztrácí při inicializaci proměnné \inlineCode{ref} na řádku \ref{ctime:nonctime:2}. Aby se tomuto předešlo, zavedeme pravidlo, že \textbf{na \ctime data nelze odkazovat \nonctime referencí/ukazatelem na mutabilní typ}.

Toto pravidlo ale není dostatečné:
\begin{code}
class C {
	@public Int! x;
}

class D {
	@public C!?! c = new C;
}

Void main() {
	@ctime D d;
	
	D? dref := d;
	dref.c.x = 5;
}
\end{code}

Zde jsme toto pravidlo neporušili, ale přesto se nám opět podařilo porušit axiom pro \ctime. Zavedeme tedy další pravidlo: \textbf{odkaz na \ctime data nelze uložit do \nonctime reference/ukazatele, pokud všechny třídní proměnné typu reference/ukazatel v odkazovaném typu nejsou konstantní}.

Toto pravidlo se ale také dá obejít:
\begin{code}
class C {
	@public Int x;
}

class C2 : C {
	@public Int!? y = new Int;
}

class D {
	@public C? c = new C2;
}

Void main() {
	@ctime D d;
	
	D? dref := d;
	dref.c.to( C2? ).y = 5;
}
\end{code}

Řešení tohoto problému už je značně problematické. Kvůli způsobu implementace by zápis do paměti připadající \ctime datům vedl k nedefinovanému chování aplikace, takže je třeba mu zabránit. Všem těmto komplikacím by se předešlo vynucením tranzitivity konstantnosti přes referenci a vzniká tak dilema, zda tranzitivitu vynutit i za cenu omezení možností programátora, nebo ponechat programátorovi místo, kde by se nechtěně mohl "střelil do nohy". Na základě názoru, že "jazyk má sloužit programátorovi, ne programátor jazyku" se autor přiklání spíše k variantě nevynucovat tranzitivitu.

\subsection{Třídní \ctime proměnné}
Zvažme možnost existence nestatických \ctime proměnných ve třídách:
\begin{code}
class C {
	
@public:
	@ctime Int! y = 0;
	
@public:
	Void foo!() {
		y += 3;
	}
	
}

Void main() {
	C! c, c2;
	
	C!?! cref = select( console.read( Int ) < 4, c, c2 );
	cref.foo();
}
\end{code}

Z příkladu lze odvodit, že myšlenka není uskutečnitelná. Volání funkce \inlineCode{foo} je datově závislé na uživatelském vstup a nedá se tomu zabránit jinak, než označením proměnných \inlineCode{c}~a~\inlineCode{c2} jako \ctime (což by znemožnilo použití \inlineCode{console.read}). I kdybychom zavedli "\ctime" funkce, které jako parametry přijímají pouze \ctime data, k ničemu by nám to nebylo. Toto se dá chápat i tak, že funkce \inlineCode{foo} obsahuje skrytý parametr -- odkaz na instanci třídy. Protože proměnná \inlineCode{cref} není \ctime, právě tento parametr by porušoval axiom \ctime.

\section{Přehled odvozených pravidel} \label{ctime:rules}
\begin{enumerate}
	\item \ctime proměnné nemohou být jakkoli (datově) závislé na proměnných, které nejsou \ctime. 
	\item Statické \ctime proměnné musí být konstantní.
	\item Větvení může být \ctime, pokud je výraz v nich datově závislý pouze na \ctime proměnných.
	\begin{enumerate}
		\item Těla \ctime větvení nejsou nijak omezena.
		\item V tělech \nonctime větvení se nemůže měnit data \ctime proměnných, které byly deklarovány mimo něj (ale lze je číst).
	\end{enumerate}
	\item Je-li proměnná \ctime, jsou všechny její třídní proměnné také \ctime.
	\item Je-li reference nebo ukazatel \ctime, paměť, na kterou odkazuje, je také \ctime.
	\item Po inicializaci statické \ctime proměnné nelze zapisovat do paměti, která byla během její inicializace alokována.
	\item Ukládání \ctime proměnných do \nonctime proměnných má další omezení:
	\begin{enumerate}
		\item Na \ctime data nelze odkazovat \nonctime referencí/ukazatelem na mutabilní typ.
		\item Odkaz na \ctime data nelze uložit do \nonctime reference/ukazatele, pokud všechny třídní proměnné typu reference/ukazatel v odkazovaném typu nejsou konstantní.
	\end{enumerate}
	\item Třída (\nonctime) nemůže obsahovat nestatické \ctime proměnné.
\end{enumerate}

V dalších oddílech jsou odvozena další dodatečná pravidla. Jejich přehled je uveden v~oddílu \ref{ctime:moreRules}.

\section{Potenciál a důsledky konceptu}
Když už máme odvozená pravidla, můžeme si ukázat, co všechno nám tento koncept umožňuje.

\subsection{Optimalizace kódu}
Pokud kompilátor zná hodnoty \ctime proměnných již za doby kompilace, logicky může výpočet jejich hodnot vynechat při běhu. Kód

\begin{code}
Void main() {
	@ctime Bignum myPrime = nthPrimeNumber( 1286345 );
	console.write( myPrime );
}
\end{code}

se vyoptimalizuje do

\begin{code}
Void main() {
	console.write( 20264747 );
}
\end{code}

Toto samozřejmě umí hodně současných programovacích jazyků. Dekorátor \inlineCode{@ctime} ale dává programátorovi pevnější kontrolu nad optimalizacemi.

\subsection{Typové proměnné} \label{ctime:typeVars}
Díky tomu, že kompilátor zná hodnotu \ctime proměnné v každém bodě již během kompilace, může měnit chování \ctime proměnné na základě její hodnoty. To umožňuje zavedení mutabilních typových proměnných. Všechny třídy jsou v jazyce Beast instancemi třidy \inlineCode{Type} (i samotná třída \inlineCode{Type} je svou vlastní instancí). Identifikátory tříd jsou ekvivalentní konstantním typovým proměnným.

\begin{code}
Void main() {
	@ctime Type T = Int16;
	
	@ctime if( VERSION > 15 )
		T = Int32;
		
	T x = 4;
}
\end{code}

\begin{code}
class C {
	@static Int! x;
}

class D {
	@static Int! y;
}

void Main() {
	@ctime Type T = C;
	T.x = 5;
	
	T = D;
	D.y = 8;
}
\end{code}

Typová proměnná může existovat pouze jako \ctime.

\subsection{Šablonování a unifikace šablonových a klasických parametrů}
Koncept \ctime se dá jednoduše využít i pro parametry šablon.

\begin{code}
class TreeNode( @ctime Type Key, @ctime Type Value, @ctime Int childrenCount ) {
	
@public:
	Key! key;
	Value! value;
	This?!?[ childrenCount ] children;
	
}
\end{code}

Díky prakticky nulovému rozdílu v syntaxi \ctime a \nonctime proměnných lze šablonové a standardní parametry funkcí zapisovat do stejných závorek a libovolně je míchat:
\begin{code}
T readFromBuffer( Buffer!? buf, @ctime Type T ) {
	T? result = buf.ptr.to( T? );
	buf.ptr += T.#size;
	return result;
}

Void main() {
	Buffer! buf;
	buf.readFromFile( File( "in.txt", :read ) ); 
	Int i = readFromBuffer( buf, Int );
}
\end{code}

Dokonce lze vytvořit i speciální dekorátor, v Beastu pojmenovaný \inlineCode{@autoCtime}, který argument bere jako \ctime, pokud to je možné:
\begin{code}
Index regexFind( String pattern, @autoCtime String regex ) {
	// regex implementation
}

Void main() {
	Index r1 = regexFind( console.read( String ), "Y[a-z]+l" ); // Regex argument is known at compile time, so it is considered to be @ctime and the regex parsing is done at compile time
	
	Index r2 = regexFind( console.read( String ), console.read( String ) ); // No optimizations here
}
\end{code}

Pomocí klíčového slova \inlineCode{auto} může funkce přijmout hodnotu jakéhokoli typu
\begin{cppcode}
// C++
template< typename T1, typename T2 >
inline auto max( T1 a, T2 b ) {
	return ( a  > b ) ? a : b;
}
\end{cppcode}

\begin{code}
// Beast
@inline auto max( auto a, auto b ) = select( a > b, a, b );
\end{code}

\subsection{\ctime funkce a třídy}
Pro usnadnění práce programátora se zavádí i podpora dekorátoru \inlineCode{@ctime} pro funkce a~třídy.

\ctime funkce mají všechny argumenty, návratovou hodnotu, proměnné a příkazy uvnitř automaticky \ctime a není tedy třeba všechny prvky takto dekorovat.

Proměnné \ctime tříd mohou být pouze \ctime. Všechny proměnné a funkce \ctime tříd jsou \ctime.

\subsection{Reflexe kódu} \label{ctime:reflection}
Koncept také umožňuje reflexi. Vezmeme-li v úvahu, že každá třída je instancí \ctime třídy \inlineCode{Type}, stačí už jen přidat do těchto tříd další \ctime proměnné, které je popisují. Jazyk Beast zavádí \ctime konstanty jako \inlineCode{Symbol.#identifier}, \inlineCode{Function.#returnType}, třídy \inlineCode{FunctionMetadata}, \inlineCode{ClassMetadata} a funkce jako \inlineCode{Class.#member(String identifier)}, které reflexi zajišťují. Jejich dokumentaci naleznete v referenci jazyka.

\section{Implementace konceptu}
Nyní zvažme, jak by se tento koncept dal implementovat do kompilátoru.

Je zřejmé, že hodnoty \ctime proměnných se budou vypočítávat již během kompilace pomocí interpretu zabudovaného do kompilátoru.

Možnosti \ctime jsou díky \hyperref[ctime:typeVars]{typovým proměnným} a \hyperref[ctime:reflection]{reflexi kódu} větší, než co je možné udělat za běhu aplikace; v rámci \ctime se sémantika příkazů může měnit na základě vykonání jiného \ctime kódu. Kdybychom zpracování \ctime chtěli realizovat klasickým interpretem, který přijímá bajtkód, zjistili bychom, že takový kód, který by dokázal pojmout veškerou funkčnost konceptu líhnutí kódu, by v podstatě odpovídal abstraktnímu syntaktickému stromu.

Tento \ctime~"interpret" bude nutně pomalejší než konvenční interprety, protože jeho součástí je kompletní sémantická analýza. Jakmile se ale zbavíme \ctime proměnných, můžeme program klasicky převést do bajtkódu a ten poté zpracovávat konvenčním interpretem, který je rychlejší. Pro větší rychlost kompilace by tedy kompilátor jazyka Beast měl mít dva interprety: první (dále interpret prvního stupně) pracující přímo nad AST schopný pracovat i s \ctime proměnnými a~druhý (dále interpret druhého stupně) pracující nad bajtkódem. Tyto interprety se dokonce mohou postupně aplikovat na stejnou funkci:

\begin{code}
Int pow( Int x, @ctime Int exp ) {
	Int! result = 1;
	
	@ctime foreach( expTmp; 0 .. exp )
		result *= x;
		
	return result;
}

@ctime Int powed = pow( 5, 3 );
\end{code}

Výše uvedený kód by po interpretaci funkce \inlineCode{pow( 5, 3 )} pomocí \ctime interpretu vypadal (bez optimalizací) takto:

\begin{code}
Int pow( Int x, 3 ) {
	Int! result = 1;
	result *= x;
	result *= x;
	result *= x;
	return result;
}
\end{code}

Po spuštění druhého stupně interpretace (které by předcházela generace bajtkódu) by funkce už navrátila hodnotu 125, která by se uložila do proměnné \inlineCode{powed}. V tomto konkrétním případě je vhodnější celou funkci vykonat pomocí pomalejšího \ctime interpretu (protože generování bajtkódu a jeho následné vykonání je ve výsledku pomalejší), nicméně v~případech, kdy by se funkce \inlineCode{pow} se stejnou hodnotou druhého parametru (který je \ctime) volala vícekrát, je výhodnější použít dvoustupňovou interpretaci.

Bližší studium této problematiky je mimo rámec této práce. V demonstračním kompilátoru je z časových důvodů implementován pouze interpret prvního stupně. I přes faktickou existenci pouze jednoho interpretu zaveďme termíny "interpretace prvního stupně," kterým je myšleno zpracování \ctime kódu, a "interpretace druhého stupně," který referuje na vykonávání standardních funkcí za doby kompilace.

\subsection{\ctime proměnné a \nonctime reference}
Nelze tvrdit, že \ctime proměnné jsou čistě záležitostí kompilace. V momentě, kdy uložíme adresu \ctime proměnné do \nonctime reference/ukazatele (toto může nastat například i~při předávání \ctime dat jako argumentů typu reference při volání \nonctime funkcí), tak abychom zajistili funkčnost reference, musíme data této proměnné (a všech dalších proměnných, na které odkazuje) umístit do paměti i při běhu programu. Data referencovaných nestatických \ctime proměnných ve funkcích musí být uložena na zásobníku. Ačkoli je veškerý \ctime kód vykonáván interpretem prvního stupně, výsledky a dokonce i některé mezistavy musí být kopírovány při běhu aplikace.

Uvažme příklad:

\begin{code}
Void write( Int? val ) {
	console.write( val );
}
	
Void main() {
	@ctime Int! x = 3; $\label{ctime:impl:ref:1}$
	write( x ); $\label{ctime:impl:ref:2}$
	x += factorial( 10 ); $\label{ctime:impl:ref:3}$
	x += 5; $\label{ctime:impl:ref:5}$
	write( x ); $\label{ctime:impl:ref:4}$
}
\end{code}

Řádky \ref{ctime:impl:ref:1}, \ref{ctime:impl:ref:3} a \ref{ctime:impl:ref:5} jsou obsluhovány interpretem prvního stupně a řádky \ref{ctime:impl:ref:2} a \ref{ctime:impl:ref:4} se vykonávají až za běhu aplikace. Vzhledem k tomu, že parametr funkce \inlineCode{write} je předáván odkazem, musí existovat místo v paměti, které je funkci předáno a které obsahuje aktuální hodnotu proměnné \inlineCode{x}. Hodnota nemusí být aktualizována vykováváním samotného výpočtu -- mašinerii pro výpočet faktoriálu lze nahradit jednoduchou \textit{mov} nebo \textit{xor} instrukcí -- a~nemusí být aktualizována vždy -- například mezi řádky $\ref{ctime:impl:ref:3}$ a $\ref{ctime:impl:ref:5}$ není žádný \nonctime kód, který by s daty pracoval a není tedy třeba promítat změny $\ref{ctime:impl:ref:3}$ okamžitě do paměti. 

\subsubsection{Paměťové prostory}
Je třeba také brát v potaz existenci dvou adresových prostorů -- virtuálního, se kterým se pracuje během kompilace, a skutečného, který je zaveden při běhu programu. Interpret v~kompilátoru nutně nemusí být implementován s klasickým adresovým prostorem, pro funkčnost ukazatelové aritmetiky v \ctime se ale jedná o nejintuitivnější řešení a demonstrační kompilátor je tímto způsobem implementován.

\begin{code}
Void foo() {
	@ctime Int! x = 3;
	@ctime Int? ctXRef := x;
	Int? xRef := x;
}
\end{code}

Ve výše uvedeném příkladu je proměnná \inlineCode{cXRef} \ctime, kompilátor tedy musí vědět, kam odkazuje. To při našem návrhu interpretu znamená, že proměnné \inlineCode{x} musí být přiřazena adresa již za doby kompilace. Nedá se předpokládat, že adresa proměnné \inlineCode{x} bude za běhu stejná jako za doby kompilace. Kromě toho za doby kompilace bude proměnná \inlineCode{x} existovat pouze v jedné instanci -- protože funkce \inlineCode{foo} není \ctime, hodnoty lokálních \ctime proměnných budou mít vždy ve stejném místě v kódu stejnou hodnotu; interpretu prvního stupně tedy stačí vykonat \ctime část funkce pouze jednou.

Je tedy třeba zavést mapování z adresového prostoru interpretu prvního stupně do adresového prostoru aplikace, případně interpretu druhého stupně. Toto mapování může mít tři formy:
\begin{enumerate}
	\item Mapování adres statických dat (pevná adresa)
	\item Mapování adres lokálních proměnných (na zásobníku -- \textit{base pointer offset})
	\item Mapování adres \ctime bloků, které byly dynamicky alokovány při vykonávání \nonctime funkce
\end{enumerate}

Třetí forma se dá demonstrovat tímto příkladem:
\begin{code}
Void foo() {
	@ctime Int!?! x := new Int!( 5 );
	console.write( x );
	x += 5;
	console.write( x );
	delete x;
}
\end{code}

Zde se při každém volání funkce \inlineCode{foo} dynamicky alokuje proměnná typu \inlineCode{Int}. Protože dynamická alokace je součástí inicializace \ctime proměnné, je obsluhována interpretem prvního stupně. Interpret tím pádem musí zajišťovat (generováním vhodných instrukcí) promítání změn proměnné odkazované z \inlineCode{x} do paměti běžící aplikace. V tomto konkrétním případě je jednoduché odvodit, že adresa je uložena v proměnné \inlineCode{x}, vezmeme-li ale v úvahu vícenásobnou indirekci v \ctime datech a optimalizaci promítání změn (takže změny dat jsou promítány v dávkách, až když je to potřeba -- kompilátor tedy v době promítání již "neví," přes které odkazy se k danému bloku dat dostal), problém na triviálnosti ztrácí.

Naivním řešením tohoto problému je uchovávat adresy všech bloků, které byly dynamicky alokovány při vykonávání \ctime kódu, jako skryté proměnné na zásobníku -- to ale může při větším počtu dynamických alokací způsobovat potíže s místem na zásobníku. Zkoumání efektivnějších řešení této problematiky je ale mimo rámec této práce. Demonstrační kompilátor to řeší právě uvedeným naivním způsobem.

Demonstrační kompilátor kvůli mapování adres uchovává informace o tom, na kterých místech paměti interpretu jsou ukazatelé a reference (podle volání konstruktorů a destruktorů). 

Aby se skryly rozdíly mezi adresovým prostorem interpretu a adresovým prostorem za běhu a předešlo se tak případným problémům (například by hašovací tabulka v \ctime generovala hashe na základě hodnot ukazatelů, ale za běhu by adresy byly jiné a tabulka by tím pádem byla neplatná), Beast dává \ctime ukazatelům a referencím následující omezení:
\begin{enumerate}
	\item Přetypování mezi referenčním a nereferenčním typem není možné (nelze přetypovat ukazatel/referenci na ordinální typ ani naopak).
	
	Toto se dá obejít přetypováním adresy ukazatele na Pointer( Void ) a pak na ordinální typ pomocí kódu \inlineCode{pointer.addr.to( Pointer( Void ) ).to( Pointer( Index ) ).data}, ale tomu se nedá zabránit. Takovéto přetypování programátor používá na vlastni nebezpečí.
	
	\item Provnávání (\inlineCode{< > <= >=}, lze \inlineCode{== a !=}) a rozdíl dvou ukazatelů je možný pouze pro ukazatele, které ukazují na stejný blok paměti (v jiných případech kompilátor zobrazí chybu). Toto omezení je kontrolováno interpretem při vykonávání.
\end{enumerate}

\subsection{\ctime větvení a sémantická kontrola}

Uvažme následující příklad:
\begin{code}
class C {
	Int! x;
}

class D {
	Int! y;
}
	
Void main() {
	@ctime Type T = C;
	@ctime T a;
	
	@ctime if( a.#type == C )
		a.x = 5;
	else
		a.y = 5; $\label{ctime:impl:branch:1}$
}
\end{code}

Aby kód správně fungoval, sémantická kontrola v \inlineCode{else} větvi podmínky (řádek \ref{ctime:impl:branch:1}) nesmí proběhnout, protože proměnná \inlineCode{a} nemá člena \inlineCode{y}. Tento případ není okrajovou záležitostí -- v~reálném \ctime kódu by obdobné problémy nastávaly na spoustě míst. \textbf{Sémantická kontrola tedy neprobíhá ve větvích \ctime větvení, které neproběhnou.} Na druhou stranu ale také musí probíhat pro každou iteraci cyklů:

\begin{code}
class C { 
	Int! x;
}
	
Void main() {
	@ctime Type[] arr = [ Int16, Int32, C ];
	@ctime foreach( Type T; arr ) {
		T var;
		
		@ctime if( T == C )
			var.x = 5;
		else
			var = 5;
	}
}
\end{code}

\subsection{Šablonování}
Následující dva příklady mají stejný význam a podobnou funkčnost:
\begin{cppcode}
// C++
template< int i >
int foo( int j ) {
	return i * i * j;
}
\end{cppcode}

\begin{code}
// Beast
Int foo( @ctime Int i, Int j ) {
	return i * i * j;
}
\end{code}

\ctime proměnné v tomto příkladu suplují parametry šablon. Po doplnění hodnoty do parametru \inlineCode{i} (který je \ctime, a tedy je třeba znát jeho hodnotu již za doby kompilace), dejme tomu \inlineCode{10}, kompilátor vygeneruje funkci v podobě:

\begin{code}
Int foo( 5, Int j ) {
	return 25 * j;
}
\end{code}

V případě, že se někde jinde v kódu volá funkce \inlineCode{foo} se \textit{stejnými} \ctime argumenty, zdánlivě není třeba generovat další funkci, protože by se chovala naprosto stejně; kompilátor může využít již vygenerovaný kód. Stejnými \ctime argumenty se myslí bitově shodná data; nelze uvažovat shodu podle operátoru \inlineCode{==}, protože bitově rozdílná data mohou i~přes sémantickou shodu vést k rozdílným výsledkům výpočtu (například i když jsou dva binární stromy shodné, jejich hloubka může být různá a výsledky výpočtů pracujících s hloubkou se nemusí shodovat).

Tvrzení, že bitově stejné \ctime argumenty generují stejné funkce, ale není ve všech případech platné. Uvažme tento příklad:
\begin{code}
Int calc( Int x, @ctime Int!? y ) {
	y ++;
	return x + y;
}

Void main() {
	@ctime Int! y = 1;
	Int f = 0;
	f += calc( 5, y ); $\label{ctime:impl:templ:1}$
	f += calc( 5, y ); $\label{ctime:impl:templ:2}$
}
\end{code}

Ačkoli zde funkce \inlineCode{calc} při volání na řádcích \ref{ctime:impl:templ:1} a \ref{ctime:impl:templ:2} přijímá bytově stejné \ctime argumenty, v prvním případě navrací \inlineCode{x + 2} a ve druhém \inlineCode{x + 3}. Nedá se tedy zaručit, že dvě funkce generované ze stejných \ctime argumentů budou totožné, a nejjednodušším způsobem je funkci pokaždé generovat. Na tento problém lze aplikovat řadu optimalizačních algoritmů, jejich rozvedení je ale mimo rámec této práce.

\subsection{Typové proměnné}
Typové proměnné lze z formálního hlediska považovat za typické \ctime proměnné. Přístup ke statickým prvkům typu, jako například v tomto příkladu:

\begin{code}
class C {
	@static @ctime Int x = 5;
}

class D {
	@static @ctime Int y = 6;
}
	
Void main() {
	@ctime Type T = C;
	console.write( T.x );
	
	T = D;
	console.write( T.y );
}
\end{code}

je funkčně ekvivalentní s přepsáním \textit{dispatch} operátoru\footnote{\BeastRef{The '\inlineCode{x.ident}' (dispatch) operator}}. Jediným případem, kdy se typová proměnná liší od ostatních \ctime proměnných, je konstrukt \inlineCode{Type ident( args )} (a~jeho varianty) pro deklaraci proměnné.


\section{Přehled doplňujících pravidel} \label{ctime:moreRules}
Tento přehled pravidel doplňuje ten uvedený v oddílu \ref{ctime:rules}.

\begin{enumerate}
	\item Je zakázáno přetypovávat \ctime ukazatel na jiný než referenční \ctime typ a naopak.
	\item Nelze porovnávat (\inlineCode{< > <= >=}, lze \inlineCode{== a !=}) ani vypočítat rozdíl \ctime ukazatelů, které patří do různých alokačních bloků paměti.
	\item Pro nevykonané \ctime větve se neprovádí sémantická kontrola. U \ctime cyklů se provádí sémantická kontrola pro každou iteraci zvlášť.
\end{enumerate}
