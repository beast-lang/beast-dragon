% !TeX spellcheck = en_US

\include{header}
\include{mainpage}
\include{support}

\setlength\extrarowheight{2pt}

% Title Page
\title{BEAST programming language}
\subtitle{Language specification/reference}
\author{Daniel 'Danol' ÄŒejchan}
\date{2016}


\begin{document}
\mainpage
%\renewcommand{\clearpage}{}

\chapter{Table of contents}
\makeatletter
\setcounter{tocdepth}{1}
\@starttoc{toc}
\makeatother

\chapter{Introduction}
BEAST is an imperative, structured, modular programming language supporting OO and functional paradigms. Currently, only transcompilation to C++ is available. In future, a LLVM backend integration is planned.

BEAST is a practical tool for practical programmers. With BEAST, you can write effective and readable code quite fast. Although the language itself builds on a significant abstraction, the functionality behind it is still close to HW. If you know the language, you can pretty well determine what assembly each line of your code generates.

Basic language classification:
\begin{compactitem}
	\item Imperative
	\item Classes are instances of \verb|Type| class
	\item Statically typed
\end{compactitem}

\section{Why choose BEAST}
\begin{itemize}
	\item \textbf{Good programming practices} BEAST gently pushes you into writing your code readable and understandable.
	\item \textbf{Compile-time magic} In BEAST, you can do many things much more comfortably using compile time function execution.
	\item \textbf{Language reflection} BEAST has easy ways to get information about symbols, list class members, etc.
	\item \textbf{Modules} In BEAST, you don't have to write separate header and source files and struggle with keeping them consistent.
\end{itemize}

\section{Inspiration}
\paragraph{Inspiration from C++}
\begin{compactitem}
	\item Class system, multiple inheritance
	\item Most of the syntax
	\item \hyperref[userDefinedLiterals]{User-defined literals}
\end{compactitem}

\paragraph{Inspiration from D}
\begin{compactitem}
	\item Module system
	\item Compile time function execution
\end{compactitem}

\paragraph{Ideas not directly inspired by other languages}
\begin{compactitem}
	\item Overall collaboration of compile-time function execution
	\item Language reflection
	\item The \hyperref[colonAccessor]{\kwd{:}} accessor
	\item The \hyperref[constantValueParameter]{constant value function parameters}	
	\item Decorators
\end{compactitem}

\chapter{Lexical}
In a normal code, BEAST accepts only standard ASCII characters. Non-ascii characters are allowed only in comments and string literals.

\begin{grammar}
	\tokenDef{Whitespace} \verb|[\n\t ]+|
\end{grammar}

\section{Identifiers}
\begin{grammar}
	\tokenDef{Identifier} \verb|#?[a-zA-Z_][a-zA-Z_0-9]*|
\end{grammar}
An identifier consists of any combination of lower and upper case ASCII letters, numbers and undescores, with these additional rules:
\begin{itemize}
	\item An identifier cannot begin with a number.
	\item An identifier can begin with the hasthag (\verb|#|) character. These identifiers are used in various language constructs and can have restrictions of where and how they can be used in declarations.
\end{itemize}

\section{Keywords} \label{keywords}
\begin{code}
alias, auto, break, case, class, continue, else, enum, for, if, import, in, is, module, return, switch, this, while
\end{code}

\subsection{Reserved words}
\begin{code}
asm, auto, blueprint, debug, declaration, declare, decorator, delegate, do, except, extend, finally, foreach, function, generic, goto, loop, mixin, scope, singleton, template, throw, try, with, yield
\end{code}

\section{Literals}
\begin{grammar}
	\grDef{Literal} \gr{UnitLiteral} [ \token{Identifier} ] \\
	\grDef{UnitLiteral} \gr{StringLiteral} \\
		\grAltLn \gr{IntLiteral} \\
		\grAltLn \gr{BinLiteral} \\
		\grAltLn \gr{OctLiteral} \\
		\grAltLn \gr{HexLiteral} \\
		\grAltLn \gr{FloatLiteral} \\
\end{grammar}

\subsection{Boolean 'literals'}
BEAST does provide \inlineCode{true} and \inlineCode{false}, however those are not keywords or literals, but just \decoratorRef{ctime} variables defined from the runtime library. That means that they can be redefined.

\subsection{The 'null' 'literal'}
The \inlineCode{null} is a \typeRef{Type} which is statically implicitly castable to pointer or reference of any type. It is not a keyword; it is defined in runtime library and thus can be redefined.

\subsection{Integer literals}
\begin{grammar}
	\tokenDef{IntLiteral} \verb|-?[0-9]+| \\
	\tokenDef{BinLiteral} \verb|-?0b[01]+| \\
	\tokenDef{OctLiteral} \verb|-?0o[0-7]+| \\
	\tokenDef{HexLiteral} \verb|-?0x[0-9a-fA-F]+|
\end{grammar}

\paragraph{Data type} Type of a literal is always the smallest signed type possible. If the number doesn't fit in the signed variant but fits in the unsigned variant with the same size, the unsigned variant is used (doesn't apply to negative literals). If the required bit count exceeds 128, a \typeRef{BigInt} type is used.

\begin{code}
10 // Int8
128 // UInt8
-10 // Int8
-150 // Int16
60000 // Int16
0xaa // UInt8
0xa01 // UInt16
\end{code}

\subsection{Float literals}
\begin{grammar}
	\tokenDef{FloatLiteral} \verb|-?[0-9]*\.[0-9]+([eE][+-]?[0-9]+)?|
\end{grammar}

\paragraph{Data type} Float literal is always of type \typeRef{Float64}. It is recommended to use the \verb|f| for casting to \typeRef{Float32} (alternatively, you can use the explicit cast).

\subsection{User-defined literals} \label{userDefinedLiterals}
BEAST supports a syntactical construct that allows users to define their own literals. The user defined literal is then represented by a standard BEAST literal followed by an identifier.

An appropriate function with prototype
\begin{code}
@ctime auto #literal( String suffix, String value, Literal type );
\end{code}
is then called where the first argument is the \token{Identifier} used, the second is the literal value (stringified) and the third is the type of the literal.

\begin{code}
enum Literal {
	stringLiteral,
	intLiteral,
	binLiteral,
	octLiteral,
	hexLiteral,
	floatLiteral;
	
@public:
	enum : Set {
		number = intLiteral | floatLiteral;	
	}
}
\end{code}

\begin{code}
@ctime Float32[ String ] lengthUnits = [
	"km": 1e3, "m": 1, "dm": 1e-1, "cm": 1e-2, "mm": 1e-3
];
	
@ctime Length #literal( String suffix, String value, Literal type )
	if( type is :number && suffix in lengthUnits.keys )
{
	return Length( value.to( Float32 ) * lengthUnits[ unit ] );
}

// Here, the #literal function is called with arguments #literal( "cm", "32.5", Literal.floatLiteral )
Length len = 32.5 cm;
\end{code}

\paragraph{TODO} string literals, char literals

\section{Comments}
\begin{grammar}
	\tokenDef{LineComment} \verb|//[^\n$][\n$]| \\
	\tokenDef{Comment} \verb|/\*.*?\*/|
\end{grammar}
Additionally, \textbf{comments can be nested}.

\begin{code}
void main() {
	/* This is a comment
		/* This is a comment, too. */
		Still a comment */
	thisIsACode();
}
\end{code}

\chapter{Expressions}
\begin{grammar}
	\grDef{Expression} \gr{AssignExpr} \\
		\grAltLn \token{Identifier} \kwd{->} \gr{AssignExpr} \\
		
	\grDef{CommaExpression} \gr{Expression} \{ \kwd{,} \gr{Expression} \} \\
	
	\\
	
	\grDef{ParentCommaExpr} \kwd{(} [ \gr{PrntCommaExprItem} \{ \kwd{,} \gr{PrntCommaExprItem} \} [ \kwd{,} ] ] \kwd{)} \\
	\grDef{PrntCommaExprItem} \{ \gr{Decoration} \} \gr{Expression} [ \kwd{...} ] \\
	
\end{grammar}

\section{Operators}
\begin{grammar}	
	\grDef{AssignExpr} \gr{RangeExpr} \\
		\grAltLn \gr{RangeExpr} \gr{AssignOpOp} \gr{RangeExpr} \\
		\grAltLn \gr{RangeExpr} \kwd{=>} \gr{RangeExpr} \\
		\grAltLn \gr{RangeExpr} \{ \kwd{=} \gr{RangeExpr} \}+ \\
		\grAltLn \gr{RangeExpr} \{ \kwd{:=} \gr{RangeExpr} \}+ \\
	
	\grDef{RangeExpr} \gr{LogicExpr} \\
		\grAltLn \gr{LogicExpr} \kwd{..} \gr{LogicExpr} \\
	
	\grDef{LogicExpr} \gr{CmpExpr} \\
		\grAltLn \gr{CmpExpr} \{ \kwd{\&\&} \gr{CmpExpr} \}+ \\
		\grAltLn \gr{CmpExpr} \{ \kwd{||} \gr{CmpExpr} \}+ \\
		
	\grDef{CmpExpr} \gr{BitExpr} \\
		\grAltLn \gr{BitExpr} ( \kwd{is} | \kwd{!is} | \kwd{in} | \kwd{!in} | \kwd{!=} ) \gr{BitExpr} \\
		\grAltLn \gr{BitExpr} \{ ( \kwd{==} | \kwd{>=} | \kwd{>} ) \gr{BitExpr} \}+ \\
		\grAltLn \gr{BitExpr} \{ ( \kwd{==} | \kwd{<=} | \kwd{<} ) \gr{BitExpr} \}+ \\
		
	\grDef{BitExpr} \gr{SumExpr} \\
		\grAltLn \gr{UnaryExpr} ( \kwd{>{}>} | \kwd{<{}<} | \kwd{>{}>{}>} | \kwd{<{}<{}<} ) \gr{UnaryExpr} \\
		\grAltLn \gr{UnaryExpr} \{ \kwd{\&} \gr{UnaryExpr} \}+ \\
		\grAltLn \gr{UnaryExpr} \{ \kwd{|} \gr{UnaryExpr} \}+ \\
		\grAltLn \gr{UnaryExpr} \{ \kwd{\^} \gr{UnaryExpr} \}+ \\
	
	\grDef{SumExpr} \gr{MultExpr} \\
		\grAltLn \gr{MultExpr} \{ ( \kwd{+} | \kwd{-} ) \gr{MultExpr} \}+ \\
	
	\grDef{MultExpr} \gr{VarDeclExpr} \\
		\grAltLn \gr{VarDeclExpr} \{ ( \kwd{*} | \kwd{/} ) \gr{VarDeclExpr} \}+ \\
		\grAltLn \gr{VarDeclExpr} \kwd{\%} \gr{VarDeclExpr} \\
		
	\grDef{VarDeclExpr} \gr{UnaryExpr} \\
		\grAltLn \gr{UnaryExpr} \token{Identifier} [ \gr{ParentCommaExpr} ] \\
		\grAltLn \kwd{new} \gr{UnaryExpr} [ \gr{ParentCommaExpr} ] \\
	
	\grDef{UnaryExpr} \gr{P1Expr} \\
		\grAltLn ( \kwd{!} | \kwd{-} | \kwd{\~} | \kwd{++} | \kwd{-{}-} ) \gr{P1Expr} \\
		\grAltLn \gr{P1Expr} ( \kwd{++} | \kwd{-{}-} ) \\
		\grAltLn \gr{P1Expr} \{ \kwd{?} | \kwd{!} \}+ \\
		\grAltLn \gr{InlineVarDecl} \\
		\grAltLn \kwd{\$} \\
	
	\grDef{P1Expr} \gr{AtomExpr} \\
		\grAltLn \gr{AtomExpr} \{ \gr{P1Op} \} \\
	
	\grDef{AtomExpr} [ \kwd{:} ] \token{Identifier} \\
		\grAltLn \gr{Literal} \\
		\grAltLn \kwd{(} \gr{Expression} \kwd{)} \\
		\grAltLn \kwd{[} [ \gr{ArrayLiteralExpr} \{ \kwd{,} \gr{ArrayLiteralExpr} \} [ \kwd{,} ] ] \kwd{]} \\
	
	\grDef{ArrayLiteralExpr} \gr{RangeExpr} [ \kwd{=>} \gr{RangeExpr} ] \\
	
	\grDef{AssignOpOp} \kwd{+=} | \kwd{-=} | \kwd{*=} | \kwd{/=} | \kwd{\%=} | \kwd{\&=} | \kwd{|=} | \kwd{\^{}=} | \kwd{<{}<=} \\
		\grAltLn \kwd{>{}>=} | \kwd{<{}<{}<=} | \kwd{>{}>{}>=} \\
	
	\grDef{P1Op} \gr{ParentCommaExpr} \\
		\grAltLn \kwd{[} [ \gr{Expression} \{ \kwd{,} \gr{Expression} \} [ \kwd{,} ] ] \kwd{]} \\
		\grAltLn \kwd{.} \token{Identifier} \\
\end{grammar}

\subsection{Operator precedence}
\begin{centeredRefTabular}{P{1.5cm} | c | c | p{6cm} | c}
	\textbf{Priority} & \textbf{Operator} & \textbf{Enum} & \textbf{Semantics} & \textbf{Assoc.} \\ \hline \hline
	
	1
		& \inlineCode{x(args)} & \inlineCode{funcCall} & Function call & \multirow{3}{*}{L$\rightarrow$R} \\
		& \inlineCode{x[args]} & \inlineCode{brackets} & Array subscripting & \\
		& \inlineCode{x.ident} & \inlineCode{dispatch} & Attribute access & \\
	\hline
	
	2
		& \inlineCode{!x} & \inlineCode{preNot} & Logical NOT & \multirow{5}{*}{NOCH} \\
		& \inlineCode{-x} & \inlineCode{preMinus} & Sign negation & \\
		& \inlineCode{x} & \inlineCode{preTilde} & Bitwise NOT & \\
		& \inlineCode{++x} & \inlineCode{preInc} & Prefix increment & \\
		& \inlineCode{--x} & \inlineCode{preDec} & Prefix decrement & \\
		\cline{2-5}
		& \inlineCode{x++} & \inlineCode{suffInc} & Suffix increment & \multirow{2}{*}{NOCH} \\
		& \inlineCode{x--} & \inlineCode{suffDec} & Suffix decrement & \\
		\cline{2-5}
		& \inlineCode{x!} & \inlineCode{suffNot} & Mutable type & \multirow{2}{*}{L$\rightarrow$R} \\
		& \inlineCode{x?} & \inlineCode{suffRef} & Reference type & \\
		\cline{2-5}
		& \inlineCode{\$} & \inlineCode{dollar} & Array size (can only be used inside the \inlineCode{brackets} operator) & \\
	\hline
	
	3
		& \inlineCode{x id( args )} & (not overloadable) & In-expression variable declaration & \multirow{2}{*}{NOCH} \\
		& \inlineCode{new x( args )} & \inlineCode{new_} & Dynamic construction & \\
	\hline
	
	4
		& \inlineCode{x * y} & \inlineCode{binMult(R)} & Multiplication & \multirow{2}{*}{L$\rightarrow$R} \\
		& \inlineCode{x / y} & \inlineCode{binDiv(R)} & Division \\
		\cline{2-5}
		& \inlineCode{x \% y} & \inlineCode{binMod(R)} & Modulo & NOCH \\
	\hline
	
	5
		& \inlineCode{x + y} & \inlineCode{binPlus(R)} & Addition & \multirow{2}{*}{L$\rightarrow$R} \\
		& \inlineCode{x - y} & \inlineCode{binMinus(R)} & Subtraction & \\
	\hline
	
	\multirow{4}{1.5cm}{\centering 6\\(cannot use P3, P4)}
		& \inlineCode{x & y} & \inlineCode{binAnd(R)} & Bitwise AND & \multirow{3}{*}{\parbox{1cm}{\centering L$\rightarrow$R,\\SAME}} \\
		& \inlineCode{x | y} & \inlineCode{binOr(R)} & Bitwise OR & \\
		& \inlineCode{x ^ y} & \inlineCode{binXor(R)} & Bitwise XOR / power & \\
		\cline{2-5}
		& \inlineCode{x >> y} & \inlineCode{binRSft(R)} & Bitwise right shift & \multirow{4}{*}{NOCH} \\
		& \inlineCode{x << y} & \inlineCode{binLSft(R)} & Bitwise left shift & \\
		& \inlineCode{x >>> y} & \inlineCode{binRRot(R)} & Bitwise right circular shift & \\
		& \inlineCode{x <<< y} & \inlineCode{binLRot(R)} & Bitwise left circular shift & \\
	\hline
	
	7
		& \inlineCode{x is y} & \inlineCode{binIs(R)} & Is (pattern matching) & \multirow{5}{*}{NOCH} \\
		& \inlineCode{x !is y} & \inlineCode{binIsNot(R)} & Is not & \\
		& \inlineCode{x in y} & \inlineCode{binIn(R)} & In & \\
		& \inlineCode{x !in y} & \inlineCode{binNotIn(R)} & Not in & \\
		& \inlineCode{x != y} & \inlineCode{binNeq(R)} & Not equal to & \\
		\cline{2-5}
		& \inlineCode{x < y} & \inlineCode{binLess(R)} & Less than & \\
		& \inlineCode{x <= y} & \inlineCode{binLeq(R)} & Less than or equal to & \multirow{3}{*}{\parbox{1cm}{\centering L$\rightarrow$R\\SPEC}} \\
		& \inlineCode{x == y} & \inlineCode{binEq(R)} & Equal to & \\
		& \inlineCode{x >= y} & \inlineCode{binGeq(R)} & Greater than or equal to & \\
		& \inlineCode{x > y} & \inlineCode{binGrt(R)} & Less than & \\
	\hline
	
	8
		& \inlineCode{x && y} & \inlineCode{binLogAnd(R)} & Logical AND & \multirow{2}{*}{\parbox{1cm}{\centering L$\rightarrow$R,\\SAME}} \\
		& \inlineCode{x || y} & \inlineCode{binLogOr(R)} & Logical OR & \\
	\hline
	
	9
		& \inlineCode{x .. y} & \inlineCode{binRange(R)} & Range & NOCH \\
	\hline
	
	10
		& \inlineCode{x = y} & \inlineCode{assign(R)} & Assignment & \multirow{2}{*}{\parbox{1cm}{\centering L$\rightarrow$R,\\SAME}} \\
		& \inlineCode{x := y} & \inlineCode{refAssign(R)} & Reference assignment & \\
		\cline{2-5}
		& \inlineCode{x += y} & \inlineCode{plusAssign(R)} & \multirow{12}{*}{Various assignments} & \multirow{12}{*}{NOCH} \\
		& \inlineCode{x -= y} & \inlineCode{minusAssign(R)} && \\
		& \inlineCode{x *= y} & \inlineCode{multAssign(R)} && \\
		& \inlineCode{x /= y} & \inlineCode{divAssign(R)} && \\
		& \inlineCode{x \%= y} & \inlineCode{modAssign(R)} && \\
		& \inlineCode{x &= y} & \inlineCode{andAssign(R)} && \\
		& \inlineCode{x |= y} & \inlineCode{orAssign(R)} && \\
		& \inlineCode{x ^= y} & \inlineCode{xorAssign(R)} && \\
		& \inlineCode{x <<= y} & \inlineCode{lSftAssign(R)} && \\
		& \inlineCode{x >>= y} & \inlineCode{rSftAssign(R)} && \\
		& \inlineCode{x <<<= y} & \inlineCode{lRotAssign(R)} && \\
		& \inlineCode{x >>>= y} & \inlineCode{rRotAssign(R)} && \\
		\cline{2-5}
		& \inlineCode{x => y} & (not overloadable) & Association & NOCH \\
	\hline
	
	11
		& \inlineCode{x, y} & & Comma & L$\rightarrow$R \\
\end{centeredRefTabular}

\paragraph{Associativity -- explanation}
\begin{compactitem}
	\item \textbf{L$\rightarrow$R} Operations from the same group are processed from left to right, meaning \inlineCode{x + y + z} is processed as \inlineCode{(x + y) + z}.
	\item \textbf{R$\rightarrow$L} Operations from the same group are processed from right to left, meaning \inlineCode{x = y = z} is processed as \inlineCode{x = (y = z)}.
	\item \textbf{NOCH} Operations cannot be chained with any operator of the same priority, meaning expressions like \inlineCode{x >> y >> z}, \inlineCode{x >> y << z} or \inlineCode{++!x} are syntactically incorrect.
	\item \textbf{SAME} Only the same operators can be chained, meaning \inlineCode{x & y & z} and \inlineCode{x | y | z} is correct, but \inlineCode{x & y | z} is not.
	\item \textbf{SPEC} Specific chaining rules, described in following sections.
\end{compactitem}

\paragraph{Operator precedence specialities}
In order to improve code readability, it is prohibited to use priority 3 and 4 operations as priority 5 operands -- you must wrap them in the parentheses.
\begin{code}
x + y >> z; // Error
(x + y) >> z; // Ok
\end{code}

Also, you cannot use P9 operations as operands in the \verb|[args]| operator.

\subsection{Comparison operators chaining} Comparison operators can be chained in monotonous order:
\begin{code}
// (Almost) equivalent with (a > b) && (b >= c) && (c == d) && (d >= e) && (e > f)
a > b >= c == d >= e > f;
// (Almost) equivalent with (a <= b) && (b < c) && (c <= d) && (d == e) && (e < f)
a <= b < c <= d == e < f;
// (Almost) equivalent with (a == b) && (b == c)
a == b == c;
// Syntax error
a > b < c;
\end{code}

When chaining comparison operators, the expressions in form \inlineCode{x == y > z} are internally rewritten to \inlineCode{(x == y) && (x > z)} (supports user overloaded operators), except the \verb|x|, \verb|y| and \verb|z| expressions are evaluated only once.

\paragraph{Evaluation order}
Operands are evaluated left to right, if not specified otherwise.

\section{Overloadsets (symbols, symbol lookup, identifier resolution, overloading)}
Overloadset is a language structure, a container with all symbols that match currently processed expression. Consider following example:

\begin{code}
	Void f() {}$\label{codeLine:overloadSets1:fDecl}$
	
	Void main() {
		f();$\label{codeLine:overloadSets1:fCall}$	
	}
\end{code}

Here, when processing the function call on line \ref{codeLine:overloadSets1:fCall}, the compiler starts with identifier \inlineCode{f}. It constructs an overloadset which contains the function \inlineCode{f} defined on line \ref{codeLine:overloadSets1:fDecl}. Then, it sees parentheses, so it will look up for operator \inlineCode{x(args)} in the previous overloadset and put everything it has found to a new overloadset. Then, a process which selects the best matching overload is performed (will be described later in this chapter).

Now let's explain that process step by step.

\subsection{Full identifier resolution} \label{fullIdentifierResolution}
When there's an expression that starts with an identifier (\gr{AtomExpr}, the \token{Identifier} alternative), a full resolution is performed for it. This is done by searching symbols with the desired identifier in various scopes. As soon as a match is found, the resolution ends, resulting an overloadset with all matching symbols in the currently searched set of scopes.

The rules that decide which scopes will be looked for are following:

\paragraph{Function scopes}
\begin{enumerate}
	\item Current scope
	\item Parent scope (recursive); if the current scope is a nested function (lambda) root, all parent function scopes are skipped except when the lambda does capture all outer scope variables
\end{enumerate}

\paragraph{Object (class, enum, ...) scopes}
Please note that object's dynamic and static fields are in separate scopes (depends if you're accessing an instance or an object). You can somewhat mix them using \decoratorRef{dynamicAccess}.

\begin{enumerate}
	\item Current object scope and scopes of all ancestors of the current object (whether the member is static or not is not taken into consideration in this phase). Parent scopes are not searched recursively.
	\item Scope imports of the current object and all its ancestors (scope imports are not implemented as a language feature in the current version, however some language-defined classes use them internally) and all ancestors of all the scope imports
	\item Parent scope (recursive)
\end{enumerate}

\paragraph{Module level scopes (modules, templates)}
\begin{enumerate}
	\item Current scope
	\item Parent scope (recursive)
\end{enumerate}

\begin{comment}
\textbf{Namespace scopes}
\begin{compactenum}
\item Current scope and scopes of all namespaces with the same (full) identifier in any of the modules that have been imported in the identifier resolution scope (that means also all imports derived from parent scopes).
\item Parent scope (recursive)
\end{compactenum}
\end{comment}

\textbf{If no results are found, root scopes of all imported modules are searched.} If nothing is found even then, identifier resolution ends with an empty result (or error, depending on use case).

\begin{comment}
\begin{code}
module a;

Void a() {}
Void b() {}

Void f() {
// First, we search in the current scope (inside the function) -> not found
// Then, we search in the parent scope (which is the module scope) -> found function a
a();

Int a;

// Now when we search in the current scope, we find variable a
a = 5;
}

$\moduleSep$
module b;

Void a() {}

class C {

@public:
Void a() {}
Void c() {}
Void f() {

}	

}

class D : @public C {

@public:
Void c() {}
Void g() {

}

}
\end{code}
\end{comment}

\subsection{Scoped identifier resolution} \label{scopedIdentifierResolution}
The scoped identifier resolution is similar to the full identifier resolution, except it doesn't look into parent scopes at all.

\subsection{The '\inlineCode{:ident}' accessor} \label{colonAccessor}
This language construct can only be used in parameter lists. When used, a \textbf{\hyperref[scopedIdentifierResolution]{scoped identifier resolution} is run} instead of the full identifier resolution. Also, \textbf{the resolution is not performed for the current scope but for the scope of an object the parameter is expected to be type of}.

\begin{code}
	enum Enum {
		a, b, c, d
	}
	
	Void f( Enum e ) {}
	
	Void main() {
		// Following lines are semantically identical
		f( Enum.a );
		f( :a );	
	}
\end{code}

This of course does not work with \kwd{auto} parameters (they are ignored in the overload resolution).

\subsection{Overload resolution} \label{overloadResolution}
Overload resolution is performed every time the compiler needs to match arguments to a function overload. The process is performed over an overloadset where all items must accept arguments (error is shown otherwise).

Note that not only functions accept arguments - for example parametric classes (similar to template classes) also accept arguments (they can however be considered to be compile-time functions returning a class as they are indistinguishable from them).

Overload resolution consists of these steps:
\begin{enumerate}
	\item Overloads that do not match given arguments are ignored (also considering constness and staticness)
	\begin{itemize}
		\item Constant-value parameters (for example \inlineCode{Void foo( 3, Int x )}) require \ctime arguments. Trying to resolve overload with constant-value parameter with \nonctime argument on the same index results in semantic error.
	\end{itemize}
	\item For each overload, rate each argument with a numeric value, representing argument-to-parameter mismatch rate. Remove those overloads whose mismatch rate is higher than match rate of another overload from the set for all arguments. Match rate rules:
		\begin{enumerate}[label=(\arabic*)]
			\item Exact value match (see \ref{parameterLiterals})
			\item Exact type match
			\item Type deduction needed (for example \inlineCode{foo(x => x + 1)} for prototype \inlineCode{Void foo(Function(Int, Int) func)}) or use of \inlineCode{:ident} accessor (see \ref{colonAccessor})
			\item Scope import cast needed (see \ref{scopeImports})
			\item Implicit cast needed			
			\item Parameter is of \inlineCode{auto} type
		\end{enumerate}
		For variadic parameters, the highest mismatch rate across all arguments is considered.
	
	\item Find minimal scope import nesting level of an overload in the overloadset; remove all overloads with higher nesting levels (overloads that are not from scope imports have higher priority)
	\item If there are any non-static overloads, ignore all static overloads
	\item If there are any non-compiler-generated overloads, ignore all compiler-generated overloads (implicit constructors etc)
	\item If there are any non-const overloads, ignore all const overloads
\end{enumerate}

If there's more than one overload remaining after application of the process mentioned above, the "ambiguous overloads" error occurs.

\subsection{Resolution application on expressions}
Application of the resolutions will be described in the next chapter for each operator.

\section{Operator overloading}
\begin{code}
enum Operator {
	funcCall,
	brackets,
	dispatch,
	preNot,
	// etc
	;
	
@public:
	enum : Set {
		unary = preNot | suffNot | preMinus /* etc */,
		unaryPre = preNot | preMinus | preTilde /* etc */,
		unarySuff = suffNot | suffMult | suffAnd /* etc */,
		
		binary = binMult | binDiv | binMod /* etc */,
		binaryRight = binMultR | binDivR | binModR /* etc */,
		anyAssign = assign | refAssign | plusAssign /* etc */
	}	
}
\end{code}

All operators can be overloaded. This is done by overloading/implementing function:
\begin{code}
auto #operator( @ctime Operator op, auto args ... );
\end{code}

So for example, you can overload all unary operators at once using:
\begin{code}
@final class UnaryProxy( Type T ) {
	
@public:
	Void #ctor( T? value ) {
		referencedValue = value;
	}
	
@public:
	auto #operator( @ctime Operator op, auto args ... )
		if( op is :unary )
	{
		return referencedValue.#operator( op, args ... );
	}
	
@private:
	T! referencedValue;
	
}
\end{code}

or you can overload one exact operator:
\begin{code}
Boolean #operator( Operator.preNot ) {
	return !referencedValue;	
}
Int16 #operator( Operator("x++") ) {
	return referencedValue ++;
}
\end{code}

You can also make operator overload implementations virtual (if they don't contain any ctime variables):
\begin{code}
class A {
	@public @abstract Void #operator( Operator.plusAssign, A@ other );
}

@final class B : @public A {
	@public @override Void #operator( Operator.plusAssign, A@ other ) {
		// code here	
	}
}
\end{code}

\subsection{The '\inlineCode{x.ident}' (dispatch) operator}
Consider expression
\begin{code}
x.ident
\end{code}

Here, \inlineCode{x} is the left operand and the \inlineCode{ident} is the right operand.

\paragraph{Behavior}
\begin{enumerate}
	\item Check if the left operand overloadset contains only one record (or error).
	\item Perform a scoped identifier resolution for the left operand scope, looking for the \inlineCode{ident}; return the results if any.
	\item If the resolution resulted an empty overloadset, try calling (left operand scope identifier resolution + overload resolution + call)\\ \inlineCode{instance.#operator( Operator.dispatch, "ident" )}
	\item If it fails, show an error
\end{enumerate}

\paragraph{Consequences}
The \inlineCode{x.ident} operator can result with multiple overloads. You can implement a dispatch function.

\begin{code}
class Vector( UInt16 dimensions ) {

@public:
	Float32! data[ dimensions ];
	
	(...)
	
	auto #operator( Operator.dispatch, @ctime String str )
		if( str.allMatch( x => "xyz".contains( x ) ) )
	{
		@ctime Index[ Char ] translationArray = [
			'x' => 0,
			'y' => 1,
			'z' => 2
		];
		
		Vector( str.length )	result;
		foreach( Index i, Char ch; str )
			result.data[ i ] = data[ translationArray[ ch ] ];
			
		return result;
	}
			

}

Void main() {
	Vector( 3 ) v1( 1, 2, 3 );
	auto v2 = v1.xxx; // v2 = ( 1, 1, 1 )
	auto v3 = v1.zyx; // v3 = ( 3, 2, 1 )
}
\end{code}

\paragraph{TODO} Exceptions used for overload filtering

\subsection{The '\inlineCode{x(args)}' (funcCall) operator}
Consider expression
\begin{code}
a.f( arg1, arg2 )
\end{code}

Here, \inlineCode{a.f} is the left operand and \inlineCode{arg1} and \inlineCode{arg2} are the parameter operands.

\paragraph{Behavior}
Behavior of this operator varies on the properties of the overloadset.

If the overload set contains only functions:
\begin{enumerate}
	\item Perform an overload resolution with parameters \inlineCode{( arg1, arg2 )}.
	\item Call the only resulting overload (or error).
\end{enumerate}

If not:
\begin{enumerate}
	\item Check if the left operand overloadset contains only one record (or error).
	\item Resolve and call \inlineCode{a.f.#operator( Operator.funcCall, arg1, arg2 )}.
\end{enumerate}

\paragraph{Consequences}
Behavior described above makes the function overloading work.

\paragraph{Inline variable declarations}
You can use variable declaration as a parameter. The declared variable is valid from the point declaration to end of current scope.
\begin{code}
{
	JsonDocument doc = JSON.parse( stringData, Bool isOkay );
	if( !isOkay )
		throw;
}
\end{code}

\paragraph{The '\inlineCode{x ...}' operator} is used for 'expading' a value across multiple parameter slots. It does so using \hyperref[iterators]{standard iterating process} performed at ctime.
\begin{code}
Void f( Int a, Int b, Int c ) { /* ... */ }
Void g( String x, Int a ) { /* ... */ }

Void main() {
	f( [ 1, 2, 3 ] ... ); // Valid, the array is iterated at compile time and each value is passed as a separate parameter
	g( tuple( "5", 12 ) ... ); // Valid
}
\end{code}

\subsection{The '\inlineCode{x[args]}' (brackets) operator}
Consider expression
\begin{code}
	x[ arg1, arg2 ]
\end{code}

Here, the \inlineCode{x} is the left operand and \inlineCode{arg1} and \inlineCode{arg2} are the parameters.

\paragraph{Behavior}
\begin{enumerate}
	\item Check if the left operand overloadset contains only one record (or error).
	\item Resolve and call \inlineCode{x.#operator( Operator.brackets, arg1, arg2 )} (or error).
\end{enumerate}

\subsection{The '\inlineCode{\$}' (dollar) operator}
In the bracket parameters, you can use the \inlineCode{\$} operator.

It doesn't take any operands and translates to \inlineCode{x.#operator( Operator.dollar, Index paramId )} where \inlineCode{paramId} is the index of the bracket parameter the dollar operator was used in (starting from 0).

\subsection{Unary operators}
Consider expression
\begin{code}
	++x
\end{code}

Here, \inlineCode{x} is the operand and \inlineCode{++} is the operator.

\paragraph{Behavior}
\begin{enumerate}
	\item Check if the operand overloadset contains only one record (or error).
	\item Resolve and call \inlineCode{x.#operator( op )} (or error).
\end{enumerate}

\subsection{Binary (and assign) operators}
Consider expression
\begin{code}
	x + y
\end{code}

Here, the \inlineCode{x} is the left operand, \inlineCode{y} is the right operand and \inlineCode{+} is the operator.

\paragraph{Behavior}
\begin{enumerate}
	\item Check if the operand overloadset contains only one record (or error).
	\item Resolve and call \inlineCode{x.#operator( op, y )}.
	\item If previous step did not found any matching overload, resolve and call \inlineCode{y.#operator( opR, x )} (or error).
\end{enumerate}

Every binary operator has two records in the \inlineCode{Operator} enum -- one that ends with the \inlineCode{R} and one that does not. The \inlineCode{R} here means right. For the expression shown above, the compiler would call \inlineCode{x.#operator( Operator.binPlus, y )}, eventually \inlineCode{y.#operator( Operator.binPlusR, x )}.

\subsection{The '\inlineCode{x .. y}' (range) operator}
This operator is almost equivalent to \inlineCode{Range( x.#type )( x, y )}, except it infers the Range type from expected parameter type if possible.

\subsection{The '\inlineCode{x => y}' (association) operator}
This operator is almost equivalent to \inlineCode{Association( x.#type, y.#type )( x, y )}, except it infers the Association types from expected parameter type if possible.

\subsection{The 'x, y' (comma) operator}
Operands separated by the comma are evaluated from left to right. Value of the rightmost operand is returned.

\section{Variable declarations}
\begin{grammar}
	\grDef{VarDeclCmd} \gr{TypeExpr} \token{Identifier} [ \gr{VarDeclCtor} ] \\
		\grLn \{ \kwd{,} \token{Identifier} [ \gr{VarDeclCtor} ] \} \kwd{;} \\
	\\
	\grDef{TypeExpr} \{ \gr{Decoration} \} ( \gr{UnaryExpr} | \gr{AutoType} ) \\
	\grDef{AutoType} \kwd{auto} [ \kwd{?} ] [ \kwd{!} ] \\
	\grDef{VarDeclCtor} \gr{ParentCommaExpr} | ( \kwd{=} | \kwd{:=} ) \gr{Expression} \\
\end{grammar}

Declaring a variable is a thing well known from other programming languages. Declaring a variable consists of two tasks:
\begin{compactenum}
	\item Allocating space for it (heap or stack)
	\item Calling the constructor -- evaluating \inlineCode{var.#ctor( args );}
\end{compactenum}

There are three syntactical alternatives of how to declare a variable:
\begin{compactitem}
	\item \inlineCode{Type var;} results in calling the implicit constructor \inlineCode{var.#ctor();} if presents, yield an error otherwise.
	\item \inlineCode{Type var( arg1, arg2 );} obviously calls \inlineCode{var.#ctor( arg1, arg2 );}
	\item \inlineCode{Type var = val;} calls \inlineCode{var.#ctor( val );}
	\item \inlineCode{Type var := val;} calls \inlineCode{var.#ctor( Operator.refAssign, val );} %TODO change first argument to something more reasonable (singleton?)
\end{compactitem}

\paragraph{Auto declarations}
When using \inlineCode{auto} instead of type, the type is inferred from the first argument of \gr{ParentCommaExpr} (which must be the only one) or from the value type of the \gr{Expression} after the \kwd{=}. Multiple declarations per one auto keyword are acceptable, each inferring its own type.

\paragraph{In-expression variable declarations}
In BEAST, you can declare variables inside expressions.

\subsection{Variable lifetime}
When variable's lifetime ends, it's implicit destructor \inlineCode{var.#dtor();} is called.

\paragraph{Local variables}
Local variables are destroyed as soon as their scope ends. Although this is straightforward in most cases, there are some that require further explanations:
\begin{itemize}
	\item Variables declared inside \textbf{if} conditions are destroyed after the end of the if statement, including following else statements.
	\begin{code}
if( Int i( getNumber() ) == 5 ) {
		
} else if( i == 4 ) {
	
} // i is destroyed here
	\end{code}

	\item Variables declared inside \textbf{where} conditions are destroyed at the end of every iteration as they are declared at the beginning of every iteration.
	\begin{code}
while( ( Int! x = 0 )++ < 32 ) {
	// This is WRONG! x is created every iteration, so its value for each iteration is 1. This loop would not end.
}

foreach( x; 0 .. 32 ) {
	// This loop is correct and much nicer
}
	\end{code}

	\item For variables declared inside \textbf{for}:
	\begin{compactitem}
		\item Variables in the initialization part are destroyed after the loop end
		\item Variables in the condition part are created before each iteration and destroyed after each iteration
		\item Variables in the post-loop part are destroyed just after the post-loop part is executed
	\end{compactitem}

	\item For variables inside \textbf{foreach}:
	\begin{compactitem}
		\item Variables in the variable declaration part are created before each iteration and destroyed after each iteration
		\item Variables in the iterated expression part are destroyed when the foreach ends.
	\end{compactitem}

	\item Variables inside the \textbf{switch} expression part are destroyed when the switch ends.
\end{itemize}

\paragraph{Static variables} are destroyed when the program ends in the reverse order they were constructed.

\paragraph{Static \decoratorRef{ctime} variables} are never destroyed (they were created before the program started).

\chapter{Functions}
\begin{grammar}
	\grDef{FunctionDecl} \gr{TypeExpr} \token{Identifier} \gr{ParentCommaExpr} ( \gr{FunctionDefPart} | \kwd{;} ) \\
	\grDef{FunctionDefPart} [ \gr{FunctionDefConstraint} ] ( \gr{CommandBlock} | \kwd{=} Expression )\\
	\grDef{FunctionDefConstraint} \kwd{if} \kwd{(} \gr{Expression} \kwd{)} \\
	\\
	\grDef{CommandBlock} \kwd{\{} \{ \gr{Command} \} \kwd{\}} \\
	\grDef{Command} \gr{VarDeclCmd} \\
		\grAltLn \gr{CommaExpression} \kwd{;} \\
\end{grammar}

\section{Definition constraint}

\section{One-line function definition}

\section{Variadic functions}

\section{The \kwd{auto} keyword}

\section{Parameter namespace accessor (\texttt{:ident})}

\chapter{Types}

\subsection{Type casting}

\subsection{Pointers vs. references}
\begin{centeredRefTabular}{l | c | c}
	\textbf{Property} & \textbf{Reference} & \textbf{Pointer} \\ \hline \hline
	
	Pointer arithmetics & no & yes \\ \hline
	Can be \inlineCode{null} & yes & yes \\ \hline
	Rebindable & yes & yes \\ \hline
	Binding & \inlineCode{ref := val} & \inlineCode{ptr = val.addr} \\
		& or \inlineCode{ref := val.addr} & \\
		& or \inlineCode{ref := ref2} & \\ \hline
	Member access & \inlineCode{ref.mem} & \inlineCode{ptr.data.mem} \\ \hline
	Dereference & (implicit cast) & \inlineCode{ptr.data} \\
\end{centeredRefTabular}

\chapter{Modules}
\begin{grammar}
	\grDef{ModuleEntry} \kwd{module} \gr{ModuleIdentifier} \kwd{;} \{ \gr{ModuleLvlDecl} \} \\
	\grDef{ModuleIdentifier} \token{Identifier} \{ \kwd{.} \token{Identifier} \} \\
	\\
	\grDef{ModuleLvlDecl} \gr{ModuleLvlDeclBlock} \\
		\grAltLn \gr{ImportStmt} \\
		\grAltLn \gr{FunctionDecl} \\
		\grAltLn \gr{ScopeDecorationStmt} \\
	\grDef{ScopeDecorationStmt} \{ \gr{Decoration} \}+ \kwd{:} \\
	\grDef{ModuleLvlDeclBlock} \{ \gr{Decoration} \} \kwd{\{} \gr{ModuleLvlDecl} \kwd{\}} \\
\end{grammar}

The program is divided into modules. Each module begins with a module declaration statement.
\begin{code}
module package.package.moduleName;
\end{code}

The \gr{ModuleIdentifier} in the \gr{ModuleEntry} then works as an identifier for the module. Multiple modules with the same identifier are not allowed.

\paragraph{Filesystem representation} Module identifier has to correspond with the directory structure the source file is in and the source file name has to be same as the module name (case sensitive). For example, having set up \verb|project/src| and \verb|project/include| source file directories, module \verb|straw.beast.main| has to be in file \verb|project/src/straw/beast/main.beast| or \verb|project/include/straw/beast/main.beast|.

\paragraph{Naming convention} Modules should be named in lower-CamelCase. This is not enforced, however disobeying this rule results in a warning.

\section{Imports} \label{imports}
\begin{grammar}
	\grDef{ImportStmt} \{ \gr{Decoration} \} \kwd{import} \gr{ModuleIdentifier} \kwd{;}
\end{grammar}

Using the \kwd{import} statement, you can make symbols other modules accessible for the current scope.

Imports are not modified using standard access modifier decorators (\decoratorRef{public}, \decoratorRef{private}, etc.), but with \decoratorRef{global} and \decoratorRef{local}, \decoratorRef{local} being default.

\subsection{Local imports} \label{decorator:local}
Local import makes the symbols from the specified module accessible only for the current scope (and its subscopes).

\begin{code}
module a;

Void aFunc() {
	// Do something
}

$\moduleSep$
module b;

import a; /* Equivalent with @local import a; */

Void bFunc() {
	aFunc(); // Ok
}

$\moduleSep$
module c;

import b;

Void cFunc() {
	import a;
	aFunc(); // Ok
}
Void cFunc2() {
	aFunc(); // Error	
}
\end{code}

\subsection{Global imports} \label{decorator:global}
Symbols that are imported using the global import are accessible from the current scope (and its subscopes) and all scopes that import the current scope (and their subscopes).

\begin{code}
module a;

Void aFunc() {
	// Do something
}

$\moduleSep$
module b;

@global import a;

Void bFunc() {
	aFunc(); // Ok
}

$\moduleSep$
module c;

@global import b;

Void cFunc() {
	bFunc(); // Ok
	aFunc(); // Ok	
}

$\moduleSep$
module d;

import c;

Void Func() {
	cFunc(); // Ok
	aFunc(); // Ok
}

$\moduleSep$
module e;

import d;

Void eFunc() {
	dFunc(); // Ok
	cFunc(); // Error
	aFunc(); // Error	
}
\end{code}

\chapter{Decorators}
%TODO noWarning, final, abstract, base, virtual, override, static, noScope, virtualBase

\begin{grammar}
	\grDef{Decoration} \kwd{@} \token{Identifier} [ \gr{ParentCommaExpr} ]
\end{grammar}

Generally, decorators provide syntax support for altering properties of types, declarations or even blocks of code.

\section{Decorator application}
At module level, there are three ways of how to apply a decorator:
\begin{code}
module a;

class C {
	
// Scope decoration
@decoratorA @decoratorB:
	Int32 d;
	Int64 c;
	
	// Block decoration
	@decoratorE @decoratorF {
		Int8! b;
		Int16! c;	
	}
	
	// Statement decoration
	@decoratorC @decoratorD Int8! a;
				
}
\end{code}

\paragraph{Scope decorations} Decorators are applied to all statements following the decoration up to next scope decoration or current scope end. You cannot use scope decorations directly in the module root scope.

\paragraph{Block decorations} Decorators are applied to all statements in the block.

\paragraph{Statement decorations} Decorators are applied to the statement that follows the decoration.

\subsection{Decoration contexts} \label{decorationContexts}
The concept of decorators wraps up lot of possibilities and functionality. In order to make things work, it is necessary to define different types of decorators, each altering the program in a different, unique way. In BEAST, these decorator subtypes are called \textit{decorator contexts}. Each decorator is defined for one particular context. However decorator identifiers are overloadable, so it is possible to define multiple decorators for different contexts with the same name.

The contexts are following (decorators of contexts commented with "system only" cannot be defined by the programmer):
\begin{code}
enum DecorationContext {
	importModifier, // system only
	parameterModifier, // system only
	accessModifier, // system only for now
	metadata, // concept, not fully documented
	fieldWrapper, // concept, not fully documented
	typeWrapper, // concept, not fully documented
	typeMixin, // concept, not fully documented
	functionModifier, // system only
	classModifier, // system only
	enumModifier, // system only
	variableModifier, // system only
	controlStatementModifier, // system only
	codeBlockModifier // system only
}
\end{code} \label{enum:DecorationContext}
%TODO better ordering

%TODO context description
\subsubsection{The 'importModifier' decoration context}

\subsection{Decorator overloading}
Decorators can take parameters, just like functions (\inlineCode{@decoration} is equivalent to \inlineCode{@decoration()}). The behavior is following:
\begin{enumerate}
	\item Overloads that do not match given arguments are ignored
	\item Find overload that has lowest-index context (as ordered in the \enumRef{DecorationContext} enum) and remove overloads that are of different context
	\item Remove those overloads whose list of required implicit casts is superset of any other overload's required implicit cast list in the overloadset
	\begin{itemize}
		\item \inlineCode{auto} arguments are treated as implicit casted
		\item Arguments containing \inlineCode{:ident} accessor are also treated as implicit casted
	\end{itemize}
	\item Apply the only overload remaining (or error)
\end{enumerate}

\paragraph{Decorator ordering by context} In order to improve code readability and programmers' awareness, it is enforced by the compiler that decorations are ordered by the context they're used in (the order is specified in the \enumRef{DecorationContext} enum).

\subsection{Decorator conflicts}
\textbf{You cannot apply two decorators that are incompatible.} The most common case are the \hyperref[accessModifierDecorators]{access modifier decorators}.
\begin{code}
@final class C {

@public:
	@private Int8 a; // Error - @public and @private decorators are incompatible
	
}
\end{code}

\section{Predefined decorators}

\subsection{Import locality modifiers (\decoratorRef{global}, \decoratorRef{local})}
The decorators only support \decorationContextRef{importDecoration} context. See \nameref{imports}.

\subsection{Access modifiers (\decoratorRef{public}, \decoratorRef{private}, \decoratorRef{protected} and \decoratorRef{friend})} \label{accessModifierDecorators}
Access modifier decorators specify where a symbol is accessible from. They only support the \decorationContextRef{moduleLevelDeclaration} context.

\paragraph{\decoratorRef{public}} \label{decorator:public} Symbols with the \decoratorRef{public} access modifier are accessible from everywhere.

\paragraph{\decoratorRef{private}} \label{decorator:private} Symbols with the \decoratorRef{private} access modifier are accessible only from the current scope (and it's subscopes).

\paragraph{\decoratorRef{protected}} \label{decorator:protected} The \decoratorRef{protected} only makes sense when used in classes. It makes symbols accessible from the current scope, its subscopes and any scope that derives from any of its subscopes.

\paragraph{\decoratorRef{friend}} \label{decorator:friend} The \decoratorRef{friend} decorator exclusively allows access to one scope symbol, specified as the parameter. This rule has higher priority than \decoratorRef{protected} or \decoratorRef{private}.

Syntax: \inlineCode{@friend( Symbol friend )}

\begin{code}
class C {
	@private @friend( func3 ) Int8 x;
	@protected Int16 func() {
		return 32000;
	}	
	@public Int32 y;
}

@final class D : @public C {
	
@public:
	Void func2() {
		x = 6; // Error
		func(); // Ok
	}
	
}

Void func3() {
	C c;
	c.x = 5; // Ok - func3 is friend with C.x
	c.func(); // Error
	c.y = 10; // Ok
}
\end{code}

\paragraph{Inter-compatibility}
The \decoratorRef{public}, \decoratorRef{protected} and \decoratorRef{private} decorators are not compatible with any decorator from the three (this also means you can't apply them twice). Also, \decoratorRef{friend} and \decoratorRef{public} decorators are not compatible.

\subsection{The \decoratorRef{ctime} (and \decoratorRef{autoCtime}) decorator} \label{decorator:ctime} \label{decorator:autoCtime}
%TODO rework
Generally, the \decoratorRef{ctime} decorator is related with compile time execution. It supports multiple contexts and depending on the context, its semantics can slightly change.

\paragraph{Axioms overview}
\begin{itemize}
	\item A compile-time variable's value is always known at compile time (=> cannot change during runtime).
	\item A compile-time function is always evaluated at compile time. That implies that parameters must be known at compile time. The return type is also compile-time.
	\item Some runtime functions can be executed at compile time.
	\item There is a difference between a compile-time function and a function executed at compile time.
	\item A compile-time variable is implicitly castable to const runtime variable.
	\item A compile-time class contains compile-time variables.
	\item A compile-time class can contain runtime functions, but those cannot modify class' fields (they can only be const).
\end{itemize}

\paragraph{Compile-time parameters}
A function parameter decorated with \decoratorRef{ctime} is a compile-time parameter.

Compile-time parameter values must always be known at compile time. Compile-time parameters can be mutable.

Technically, a function with compile-time parameter is a function template.

\begin{code}
// 'y' and 't' parameters are compile-time
Void f( Int x, @ctime Int y, @ctime Type t ) {
	
}
\end{code}

For more info, see \nameref{ctime:parameter}.

\paragraph{Compile-time variables}
A variable decorated with \decoratorRef{ctime} is a compile-time variable. Compile-time variables defined in function bodies \textbf{can be mutable} (global compile-time variables cannot be mutable). A compile-time variable can be of a \hyperref[ctime:class]{compile-time type} (a non-compile-time variable cannot be of a~compile-time type). You cannot define a compile-time variable as a dynamic member of a non-compile-time class.

In order to prevent confusion, it is prohibited to work with runtime variables and manipulate (change values of) @ctime variables in the same expression.

\begin{code}
@ctime Type! t = Int; // t is a mutable @ctime variable that can hold types.

t x = 5; // Now we declared a variable x of type t (which is Int). It is a runtime variable.

t = String; // We're changing the @ctime variable here
t str = "asd"; // y is of type String

@ctime t str2 = "lol"; // str2 is compile time variable of type String
\end{code}

For more info, see \nameref{ctime:variable}.

\paragraph{Compile-time functions}
A function decorated with \decoratorRef{ctime} is a compile-time function. A compile-time function is always executed at compile time. It returns a \hyperref[ctime:class]{compile-time type}. Its parameters and all variables used in its body are compile-time.

The \decoratorRef{ctime} decorator should be omitted in parameter, variable and return type declaration; a warning is shown otherwise.

\begin{code}
@ctime Type TypeIntersection( Type t1, Type t2 ) {
	// if t2 is parent of t1
	if( t1 is t2 )
		return t2;
		
	// if t1 is parent of t2
	else if( t2 is t1 )
		return t1;
	
	else
		return Void;
}
\end{code}

For more info, see \nameref{ctime:function}

\paragraph{Compile-time classes}
A class decorated with \decoratorRef{ctime} is a compile-time class. Any instance of a compile-time class is a compile-time instance/variable. All its mutable member functions must be \hyperref[ctime:function]{compile-time functions}, all its member variables are \hyperref[ctime:variable]{compile-time variables} (the \decoratorRef{ctime} decorator should be omitted).

\begin{code}
@final @ctime class MyFunctionInfo {

@public:
	Void #ctor!( Function F ) {
		returnType = F.#returnType;
		parameterTypes = F.#parameters.map( x => x.type );
	}
	
@public:
	Type returnType;
	Type[] parameterTypes;	
	
}
\end{code}

For more info, see \nameref{ctime:class}.

\paragraph{Compile-time control statements}
A control statement decorated with \decoratorRef{ctime} is a compile-time control statement. In a compile-time control statement, \textbf{expressions in the statement are evaluated in compile-time, but the statement bodies are evaluated at runtime}.

All variables declared in the statement expressions are compile-time. They don't need to be decorated with the \decoratorRef{ctime} decorator.

\begin{code}
@ctime Type! t = Int8;

if( 3 == 5 )
	t = Int16; // Warning: compile-time variable modification inside a runtime control statement

// t == Int16 here
\end{code}

\begin{code}
@ctime for( Int16 x = 0; x < 20; x ++ ) {
	// x is a compile-time variable
	writeln( "lol" );
	// The code generated from this would be twenty writeln("lol") calls
}

for( Int16 x = 0; x < 20; x ++ ) {
	// x is a runtime variable, the loop is executed at runtime	
}

@ctime for( Int16 x = 0; x < 20; x ++ ) @ctime {
	// x is a compile-time variable and this entire block is also executed at compile-time (the "lol" is written into compiler console)
	writeln( "lol" );
}

\end{code}

\paragraph{Compile-time code block} A code block decorated with the \decoratorRef{ctime} is executed at compile time. All variables declared in it are compile time and they should not be decorated with the \decoratorRef{ctime} decorator.

\paragraph{The \decoratorRef{autoCtime} decorator} \label{decorator:autoCtime} This decorator works similar to the \decoratorRef{ctime}, except it only makes things compile-time when it is possible.

In \decorationContextRef{classDeclaration} and \decorationContextRef{enumDeclaration}, it makes the type compile-time if it derives from a compile-time type or if it has a nonstatic compile-time member.

In the \decorationContextRef{parameterDeclaration} context, the parameter is made compile-time whenever the function is called with a parameter value that is known at compile time.
\begin{code}
@final class HashTable( Type Key, Type Value ) {

@public:
	// You may ask, that the hell is "T!?!" ?! Don't be scared, T! means a mutable type T, T!? means non-mutable reference to mutable type and T!?! means mutable reference to mutable type (mutable reference == you can change where the reference points to using the ':=' operator)
	T!?! #operator!( Operator("x[args]"), @autoCtime Key key ) {
		Index hash = key.#hash() % tableSize_;	
		
		// Locating the record here 
	}
	
}

Void main() {
	HashTable( String, Int )! table;
	
	table[ stdin.read() ] = 5;
	
	table[ "key" ] = 10;
	// On the previous line the #key parameter is known at compile time, so the function is optimized (the hash calculation is performed at compile time)
}
\end{code}

In the \decorationContextRef{functionDeclaration} context, the function is made compile-time when all of its parameters (all of them must be decorated with \decoratorRef{autoCtime} or \decoratorRef{ctime}) and/or return type are compile time.

In the \decorationContextRef{variableDeclaration} context, the variable is made compile time if its type is compile time.

The decorator cannot be used in any other contexts.

\subsection{The \decoratorRef{noscope} decorator} \label{decorator:noscope}

\chapter{Ctime}
Ctime is a powerful concept introduced in BEAST. It provides a form of metaprogramming, but that's not all what it does.

\paragraph{Basic idea}
The ctime concept has one simple idea: to introduce a \textbf{type of variables of which value can be deduced at any line of code} (without having to run the program).

These variables will are called ctime variables in BEAST.

\paragraph{Consequences} Consequences of this one simple rule are following:

\chapter{Language reflection}

\section{Overloadsets}
\begin{code}
Overloadset #overloadset
Symbol #matchOverload( args )

class Overloadset {
}
\end{code}

\section{Symbols}
\begin{code}
String #identifier
Type #type
SymbolMetadata #symbol

class SymbolMetadata {

}
\end{code}

\section{Classes}
\begin{code}
String #className // Can be null for anonymous classes
ClassMetadata #class
Overloadset #member( String identifier )

class ClassMetadata {
}
\end{code}

\section{Function}
\begin{code}
Type #returnType
Type #returnType( args )
FunctionMetadata #function
Type #argType( Index index )
String #argIdentifier( Index index )
Bool #isVariadic

class FunctionMetadata {
	
@public:
	String identifier;
	
	
}
\end{code}

\chapter{BEAST practices \& styling guide}

\begin{itemize}
	\item Class and enum names are in \verb|UpperCamelCase|.
	\item Enum members are in \verb|lowerCamelCase|. They do not contain any enum-related prefixes.
	\item Decorator names are in \verb|lowerCamelCase|.
	\item Variable (and parameter) names are in \verb|lowerCamelCase|, type variables are in \verb|UpperCamelCase|.
	\item Function names are in \verb|lowerCamelCase|.
	\item The \verb|_| symbol can be used in identifiers as a separator (for example class \verb|PizzaIngredient_Cheese|).
\end{itemize}

\section{Further recommended code style}
\begin{itemize}
	\item Indent with tabs (so anyone can set up tab size based on his preferences)
	\item Spaces in statements like this: \inlineCode{if( expr ) \{}, opening brace on the same line
	\item Spaces around operators: \inlineCode{x + y}
	\item Decorators on the same line with decorated symbols.
\end{itemize}

\chapter{Plans for the future}
\begin{compactitem}
	\item Aliased imports
	\item Namespaces
	\item User decorators
	\item Blueprints -- "mixin classes" -- bad idea?
	\item Mixins
	\item Mixins but no mixins (not mixing a string, mixing a declaration)
	\item Lambdas
	\item Singletons
	\item Extern functions -- cooperation with other programming languages
	\item Compiler support for documentation comments?
	\item Compiler outputs intellisense data?
	\item Compiler caching
\end{compactitem}

\section{Documentation to-do}
\begin{compactitem}
	\item Virtual functions, when a class is virtual
	\item \decoratorRef{noWarning(W103)}
	\item \decoratorRef{label} (for break, continue nested)
	\item \decoratorRef{notNull}
	\item \verb|#| prefixed identifiers (rules, restrictions) + \verb|to|
	\item \inlineCode{class X : @public @final Y}
	\item Array literals
\end{compactitem}

\section{Random thoughts scrapbook}
\begin{code}
auto max( auto x, x.#type y ) = ( x > y ) ? x : y;

T!? #new( @ctime Type T ) {
	return malloc( T.#size ).to( T!? );
}

auto Int = Int32;
auto Float = Float32;

auto I1 = Int8;
auto I2 = Int16;
auto I4 = Int32;
auto I8 = Int64;
auto I16 = Int128;

Int8.#identifier == "Int8"
I8.#identifier == "I8"
I8.#name = "Int8"

decorator.ctime or decorator( ctime )
module.straw.beast.test or module( straw.beast.test )

class null {
	@public @static	T #implicitCast( Type T )
		if( T is Pointer )
	{
		module.this
		module.straw.beast.functionInAnotherModule();
		module( "asd.test" ).functionInAnotherModule();
		return T(0);
	}
}

class Void {}


// X class
class X( Int32 i ) {
}

X(5).#type == Class
X(5).#template == X
X.#type == ClassTemplate
X.#identifier == "X"
X(5).#name == "X"
X(5).#identifier == null

// Overloadsets
I8

// Constantization
Void foo() {
	Int! x = 5;
	x += 3;
	constantize x;
	
	x += 3; // Error: x is constant
}

!!!
class C( @ctime Int x, Int y ) { // y IS A RUNTIME VARIABLE

}


@noscope @ctime if( true ) // if does not create scope, so all variables declared in it are available outside its body
	Int! x;
	
\end{code}

\paragraph{Multiple inheritance}
\begin{itemize}
	\item A base class cannot be inherited twice (in any way, considering the entire inheritance tree); if it is, all inheritances but one must be decorated with \inlineCode{@virtual}. This rule is not applied if the inherited class is an interface (doesn't contain variables)
	\item Classes don't handle constructing of their virtual base classes
\end{itemize}

\subsection{Possible lists}

\begin{centeredRefTabular}{l | P{5cm} || c || c | c || c | c | c || c | c}
	\textbf{List type} & \textbf{Allocation method} & \rotableheader{Reasonable item count} & \rotableheader{FIFO} & \rotableheader{LIFO} & \rotableheader{Index access} & \rotableheader{Fast insert} & \rotableheader{Fast delete} & \rotableheader{Constant item address} & \rotableheader{Keeps order} \\ \hline \hline
	Array & $2^n$ & 1k & & * & * & & & & * \\ \hline
	Lazy array (swap delete) & $2^n$ & 10k & & & & * & * & & \\ \hline
	Linked list & $n$ or $2^n$ & $\infty$ & * & * & & * & * & * & * \\ \hline
	Tree & $n$ or $2^n$ & $\infty$ & * & * & & * & * & * & * \\ \hline
\end{centeredRefTabular}

\paragraph{Container names} container, array, list, collection, tree, table, hash, associativeXX, set

\end{document}          
