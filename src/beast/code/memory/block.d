module beast.code.memory.block;

import beast.code.toolkit;
import beast.code.memory.ptr;
import beast.code.data.var.local;
import beast.code.data.function_.expandedparameter;
import core.memory : GC;
import core.atomic : atomicOp;
import beast.code.memory.memorymgr;

/// Block of interpreter memory
final class MemoryBlock {

	public:
		enum Flag {
			noFlag = 0,
			doNotGCAtAll = 1 << 0, /// Do not garbage collect this block at all
			local = doNotGCAtAll << 1, /// Block is local - it cannot be accessed from other sessions (should not happen at all); tested only in debug; used for local and temporary variables
			runtime = local << 1, /// Memory block is runtime - cannot be read/written at compile time
			functionParameter = runtime << 1, /// Memory block represents a function parameter
			interpeter = functionParameter << 1, /// Memory block is generated by the interpreter (> is neither ctime or runtime)
			result = interpeter << 1, /// Memory block represents a result variable
		}

		alias Flags = Flag;

		enum SharedFlag {
			referenced = 1 << 0, /// The memory block is referenced from external source (codegen)
			doNotGCAtSessionEnd = 1 << 1, /// Do not garbage collect this block at the end of the session (when only blocks created in the current session are garbage collected)
			checked = 1 << 2
		}

	public:
		this( MemoryPtr startPtr, size_t size ) {
			this.startPtr = startPtr;
			this.endPtr = startPtr + size;
			this.size = size;

			assert( context.session, "You need a session to be able to allocate" );
			this.session = context.session;
			debug this.jobId = context.jobId;

			data = cast( ubyte* ) GC.malloc( size );
			data[ 0 .. size ] = 0;
		}

		~this( ) {
			GC.free( data );
		}

	public:
		/// Returns if the block is marked as runtime (just a placeholder for a static variable)
		bool isRuntime( ) {
			return flag( Flag.runtime );
		}

		/// Returns if the block is local - if it coresponds to a variable on stack
		bool isLocal( ) {
			return flag( Flag.local );
		}

		bool isFunctionParameter( ) {
			return flag( Flag.functionParameter );
		}

		void markReferenced( ) {
			atomicOp!"|="( sharedFlags, SharedFlag.referenced );
		}

		bool isDoNotGCAtSessionEnd( ) {
			return flag( SharedFlag.doNotGCAtSessionEnd );
		}

		void markDoNotGCAtSessionEnd( ) {
			atomicOp!"|="( sharedFlags, SharedFlag.doNotGCAtSessionEnd );
		}

		bool isReferenced( ) {
			return sharedFlags & SharedFlag.referenced;
		}

	public:
		bool flag( Flag flag ) {
			return ( flags & flag ) != 0;
		}

		bool flag( SharedFlag flag ) {
			return ( sharedFlags & flag ) != 0;
		}

		void setFlag( SharedFlag flag, bool set ) {
			if ( set )
				atomicOp!"|="( sharedFlags, flag );
			else
				atomicOp!"&="( sharedFlags, flag );
		}

	public:
		string identificationString( ) {
			if ( flag( Flag.result ) )
				return "#return#";

			else if ( relatedDataEntity )
				return relatedDataEntity.identificationString;

			else if ( identifier )
				return identifier;

			else
				return "#var#";
		}

	public:
		/// First byte that belongs to the block
		const MemoryPtr startPtr;
		/// First byte that doesn't belong to the block
		const MemoryPtr endPtr;
		/// Size of the block
		const size_t size;
		/// Session the current block was initialized in
		const size_t session;
		/// Flags of the block. Do not change after first write!
		Flags flags;
		/// Flags that can be modified asynchronously (atomic or write only)
		shared ubyte sharedFlags;
		ubyte* data;

		/// Data entity related to the code block
		DataEntity relatedDataEntity;
		string identifier;

		/// This is for checking if there was reading from a different thread before write
		debug bool wasReadOutsideContext;
		debug size_t jobId;

}
